---
title: Parameters from script
---

:::{.guidelines}
* Heather et al. 2025: Avoid hard-coded parameters.
:::

Discrete-event simulations (DES) require many parameters - like arrival rates, resource times, and probabilities - which often need to be changed for different scenarios and analyses. **Managing these parameters well makes your simulations easier to update, track, and reuse**.

This page focuses on the storage of parameters within  your scripts. If you want to see how to store parameters in a separate file, see the [parameters from file](parameters_file.qmd) page.

On this page, we explain:

* The **limitations** with hardcoding parameters or global variables.
* **Two recommended practices**: grouping parameters into a dedicated object and passing that object explicitly to your model.
* Strategies for handling a **large number** of parameters as your model grows.

<br>

## What not to do: hardcoding parameters

**Hardcoding** means writing parameter values directly into your code. For example:

::: {.python-content}
```{.python}
def model():
    # Hardcoded parameter values
    interarrival_time = 5
    consultation_time = 20
    transfer_prob = 0.3
    # ...rest of the model...
```
:::

:::{.r-content}
```{.r}
model <- function() {
    # Hardcoded parameter values
    interarrival_time <- 5
    consultation_time <- 20
    transfer_prob <- 0.3
    # ...rest of the model...
}
```
:::

This makes it very difficult to change the values. Modellers might choose to...

**1. Edit parameters directly in the script**.

This involves manually changing parameter values in the script each time you want to run a new scenario. Problems with this approach include:

* ❌ **Not a reproducible analytical pipeline**. Alot of manual intervention is required to re-run the model with different parameters.
* ❌ **Error-prone**. It would be easy to make mistakes or forget to update all relevant values.
* ❌ **Parameters can get lost**. If you lost your notes or forget to record what you used, you won't know what values were used for past runs. 

**2. Duplicate scripts for each scenario**.

This involves copying the entire script, changing parameters in each copy, and running them separately. Problems with this approach include:

* ❌ **Code duplication**. This means any changes - like bug fixes or improvements to the model - must be made to every copy. This is tedious and there is a risk that some copies are missed or updated incorrectly.
* ❌ **Hard to keep track**. With multiple script copies, it can become difficult to know which scripts correspond to which scenarios, and which parameters were used (as have to delve into the model code to identify them).

<br>

## A slight improvement: global parameters

A better (but still limited) approach is to **define all parameters at the top of your script**.

This way, parameters are no longer hidden within the code. It becomes much easier to see which parameters are being used, and to change the values used.

::: {.python-content}
```{.python}
# Parameters for base case
INTERARRIVAL_TIME = 5
CONSULTATION_TIME = 20
TRANSFER_PROB = 0.3

def model():
    # Use the global parameters
    # ...
```
:::

:::{.r-content}
```{.r}
# Parameters for base case
interarrival_time <- 5
consultation_time <- 20
transfer_prob <- 0.3

model <- function() {
  # Use the global parameters
  # ...
}
```
:::

For scenarios, you would define the same global variables with alternative values:

::: {.python-content}
```{.python}
# Scenario 1
INTERARRIVAL_TIME = 6
CONSULTATION_TIME = 20
TRANSFER_PROB = 0.3
```

```{.python}
# Scenario 2
INTERARRIVAL_TIME = 5
CONSULTATION_TIME = 20
TRANSFER_PROB = 0.4
```
:::

:::{.r-content}
```{.r}
# Scenario 1
interarrival_time <- 6
consultation_time <- 20
transfer_prob <- 0.3
```

```{.r}
# Scenario 2
interarrival_time <- 5
consultation_time <- 20
transfer_prob <- 0.4
```
:::

The improvements are that parameters are:

* ✅ **No longer hardcoded**. Within the model, it refers to the variable name rather than a specific value,which means we are able to now list the values in one *outside* the model logic.
* ✅ **Centralised**. All parameters are in one place, making them easier to find and change.

However, there are still several disadvantages:

* ❌ **Still inflexible**. In order to re-run the model with different scenarios, you would still need to do the approaches above - editing code directly or duplicating scripts for each scenario.
* ❌ **Not scalable**. As the number of scenarios or parameters grows, managing all these global variables becomes messy.

<br>

## Managing parameters in DES: two critical practices

To manage parameters effectively, you need to:

1. **Group parameters into a dedicated object**.
2. **Pass these objects explicitly to your model**.

Why?

* ✅ **Clear parameter sets**. Every scenario has its own object with all the parameters needed. This can be easily viewed, and comes in handy in [logs](../verification_validation/logs.qmd) to easily print a copy of all parameters used for a scenario.
* ✅ **No global variables**. By explicitly passing our parameters, we avoid accidental parameter reuse between scenarios (which is a possibility with global variables!).
* ✅ **Fewer inputs**. If all parameters are in one object, then we can just pass that as a single input to our model function/class, reducing the number of arguments we need to pass.

<br>

It's important to use **both** of these practices.

If you only do option 1 (group parameters, but use as globals), parameters might accidentally be modified elsewhere, or one scenario's parameters might affect another's.

:::{.python-content}
```{.python}
# BAD: Parameters are grouped but still global
global_params = Parameters()

def simulate():
    # Uses global_params.interarrival_time... 😬
    ...
```
:::

:::{.r-content}
```{.r}
# BAD: Parameters are grouped but still global
global_params <- list()

simulate <- function() {
  # Uses global_params$interarrival_time ... 😬
  ...
}
```
:::

If you only do option 2 (pass parameters, but don't group them), you end up with messy, error-prone code that's hard to maintain:

:::{.python-content}
```{.python}
# BAD: Parameters are passed but disorganised
def simulate(interarrival_time, consultation_time, transfer_prob, ...):
    # 10+ parameters? Hard to track!
    ...
```
:::

:::{.r-content}
```{.r}
# BAD: Parameters are passed but disorganised
simulate <- function(interarrival_time, consultation_time, transfer_prob, ...) {
  # 10+ parameters? Hard to track!
  ...
}
```
:::

<br>

::: {.python-content}

There are three implementation options: **dictionary**, **function** or **class**.

<br>

**Using a dictionary**

```{.python}
base_params = {
    "interarrival_time": 5,
    "consultation_time": 20,
    "transfer_prob": 0.3,
}

# Create a scenario by copying and tweaking only what's needed
scenario1 = base_params.copy()
scenario1["interarrival_time"] = 6
scenario2 = base_params.copy()
scenario2["transfer_prob"] = 0.4
```

<br>

**Using a function**

```{.python}
def create_params(interarrival_time=5, consultation_time=20, transfer_prob=0.3):
    return {
        "interarrival_time": interarrival_time,
        "consultation_time": consultation_time,
        "transfer_prob": transfer_prob
    }

base_params = create_params()
scenario1 = create_params(interarrival_time=6)
scenario2 = create_params(transfer_prob=0.4)
```

<br>

**Using a class**

```{.python}
class Parameters:
    def __init__(self, interarrival_time=5, consultation_time=20, transfer_prob=0.3):
        self.interarrival_time = interarrival_time
        self.consultation_time = consultation_time
        self.transfer_prob = transfer_prob

    def __repr__(self):
        return (f"Parameters(interarrival_time={self.interarrival_time}, "
                f"consultation_time={self.consultation_time}, "
                f"transfer_prob={self.transfer_prob})")

# Base case
base_params = Parameters()

# Scenario 1: Only change interarrival_time
scenario1 = Parameters(interarrival_time=6)

# Scenario 2: Only change transfer_prob
scenario2 = Parameters(transfer_prob=0.4)
```
:::

::: {.r-content}
There are three implementation options: **list**, **function** or **R6 class**.

<br>

**Using a list**

```{.r}
base_params <- list(
  interarrival_time = 5L,
  consultation_time = 20L,
  transfer_prob = 0.3
)

# Create a scenario by copying and tweaking only what's needed
scenario1 <- base_params
scenario1$interarrival_time <- 6L

scenario2 <- base_params
scenario2$transfer_prob <- 0.4
```

<br>

**Using a function**

```{.r}
create_params <- function(interarrival_time = 5L,
                          consultation_time = 20L,
                          transfer_prob = 0.3) {
  list(
    interarrival_time = interarrival_time,
    consultation_time = consultation_time,
    transfer_prob     = transfer_prob
  )
}

base_params <- create_params()
scenario1   <- create_params(interarrival_time = 6L)
scenario2   <- create_params(transfer_prob = 0.4)
```

<br>

**Using a R6 class**

```{.r}
library(R6)

Parameters <- R6Class(
  classname = "Parameters",
  public = list(
    interarrival_time = NULL,
    consultation_time = NULL,
    transfer_prob = NULL,
    initialize = function(
        interarrival_time = 5L,
        consultation_time = 20L,
        transfer_prob = 0.3
    ) {
      self$interarrival_time <- interarrival_time
      self$consultation_time <- consultation_time
      self$transfer_prob <- transfer_prob
    }
  )
)

# Base case
base_params <- Parameters$new()

# Scenario 1: Only change interarrival_time
scenario1 <- Parameters$new(interarrival_time = 6L)

# Scenario 2: Only change transfer_prob
scenario2 <- Parameters$new(transfer_prob = 0.4)
```

:::

<br>

### Which option is best?

The **most robust** approach is to use a **function or class** to manage your parameters.

* ✅ **Functions and classes** make it easy to create variations for different scenarios, since you simply change the inputs when you define a new scenario. For example, you can create a new scenario by only specifying the parameter you want to change, while all other parameters remain at their default values.

:::{.python-content}
* ❌ With a **dictionary**, you have to make a copy of the base dictionary and then manually change individual values for each scenario. This can become cumbersome as the number of parameters or scenarios grows - and is just a bit more clunky!
:::
::: {.r-content}
* ❌ With a **list**, you have to make a copy of the base list and then manually change individual values for each scenario. This can become cumbersome as the number of parameters or scenarios grows - and is just a bit more clunky!
:::

Your choice may be further informed by options for parameter validation, where classes can be superior as you can incorporate validation within the class, as discussed on the [parameter validation](parameters_validation.qmd) page.

:::{.r-content}
It's worth noting though that, while R does support object-oriented programming (i.e. using classes), these are less commonly used in typical R code. For most R users, sticking with functions is the standard and most straightforward approach.
:::

<br>

## Handling a large number of parameters

You may need to manage many parameters - for example, if you have several patient types and/or units each with their own arrival times, resource times, and so on.

We have suggested a few strategies you could use...

<br>

### Using a single function or class for all parameters

This can be convenient for smaller models, though can get unwieldly as the number of parameters grow, including potentially quick long parameter names!

Function example:

::: {.python-content}
```{.python}
def create_params(
    adult_interarrival=5, adult_consultation=20, adult_transfer=0.3,
    child_interarrival=7, child_consultation=15, child_transfer=0.2,
    elderly_interarrival=10, elderly_consultation=30, elderly_transfer=0.5
):
    return {
        "adult": {
            "interarrival_time": adult_interarrival,
            "consultation_time": adult_consultation,
            "transfer_prob": adult_transfer
        },
        "child": {
            "interarrival_time": child_interarrival,
            "consultation_time": child_consultation,
            "transfer_prob": child_transfer
        },
        "elderly": {
            "interarrival_time": elderly_interarrival,
            "consultation_time": elderly_consultation,
            "transfer_prob": elderly_transfer
        }
    }
```
:::

Class example:

::: {.python-content}
```{.python}
class Parameters:
    def __init__(
        self,
        adult_interarrival=5, adult_consultation=20, adult_transfer=0.3,
        child_interarrival=7, child_consultation=15, child_transfer=0.2,
        elderly_interarrival=10, elderly_consultation=30, elderly_transfer=0.5
    ):
        # Adult parameters
        self.adult_interarrival = adult_interarrival
        self.adult_consultation = adult_consultation
        self.adult_transfer = adult_transfer
        # Child parameters
        self.child_interarrival = child_interarrival
        self.child_consultation = child_consultation
        self.child_transfer = child_transfer
        # Elderly parameters
        self.elderly_interarrival = elderly_interarrival
        self.elderly_consultation = elderly_consultation
        self.elderly_transfer = elderly_transfer
```
:::

<br>

### Using multiple functions or classes

Alternatively, you can split parameters into logical groups (e.g. patient type, parameter type), each with it's own function or class. These are then combined into single parameter set.

With a large number of parameters, this keeps each individual function/class simpler.
seperate means its simpler with the inputs and stuff, just adult child elderly
also, if doing validation, can do for each subclass

Function example:

::: {.python-content}
```{.python}
def create_arrivals(adult=5, child=7, elderly=10):
    return {
        "adult": adult,
        "child": child,
        "elderly": elderly
    }

def create_consultations(adult=20, child=15, elderly=30):
    return {
        "adult": adult,
        "child": child,
        "elderly": elderly
    }

def create_transfers(adult=0.3, child=0.2, elderly=0.5):
    return {
        "adult": adult,
        "child": child,
        "elderly": elderly
    }

def create_parameters(
    arrivals=create_arrivals(),
    consultations=create_consultations(),
    transfers=create_transfers()
):
    return {
        "arrivals": arrivals,
        "consultations": consultations,
        "transfers": transfers
    }
```
:::

Class example:

::: {.python-content}
:::

```{.python}
class Arrivals:
    def __init__(self, adult=5, child=7, elderly=10):
        self.adult = adult
        self.child = child
        self.elderly = elderly


class Consultations:
    def __init__(self, adult=20, child=15, elderly=30):
        self.adult = adult
        self.child = child
        self.elderly = elderly


class Transfers:
    def __init__(self, adult=0.3, child=0.2, elderly=0.5):
        self.adult = adult
        self.child = child
        self.elderly = elderly


class Parameters():
    def __init__(
        self,
        arrivals=Arrivals(),
        consultations=Consultations(),
        transfers=Transfers()
    ):
        self.arrivals = arrivals
        self.consultations = consultations
        self.transfers = transfers
```

<br>

## Examples

The following [examples](../intro/examples.qmd) demonstrate practical implementations of structured parameter management in real simulation projects. Both use class-based approaches but scale differently based on model complexity.

---

<details>
<summary>Show/Hide example 1: Nurse visit simulation</summary>

<br>

This basic queueing model shows:

:::{.python-content}

* A single `Param` class containing all parameters.
* Direct validation within the class constructor.
* Prevention of accidental attribute creation through `__setattr__` override.
* Clear separation between configuration (parameters) and logic (model).

```{.python}
```

:::

:::{.r-content}

```{.r}
```

:::

</details>

---

<details>
<summary>Show/Hide example 2: stroke pathway simulation</summary>

<br>

This stroke pathway simulation has:

:::{.python-content}

* Multiple nested classes (`ASUArrivals`, `RehabLOS`, etc.).
* Shared `Restrict Attributes` superclass for validation.
* Three-layer structure: department --> patient type --> parameters.
* Separate validation logic from parameter storage.

```{.python}
```

:::

:::{.r-content}

```{.r}
```

:::

</details>

---

<br>
