# Parameter management {#sec-parameters}

:::{.guidelines}
* Heather et al. 2025: Avoid hard-coded parameters.
:::

Discrete-event simulations (DES) rely on many parameters lik patient arrival rates, resource usage times, and transition probilities. **Manging these parameters well is crucial**, as you'll often want to change them to test different scenarios or run sensitivity analyses.

Good parameter management means storing parameters in a way that makes them **easy to update, track, and reuse**.

<br>

## What not to do: hardcoding parameters

**Hardcoding** means writing parameter values directly into your code. For example:

::: {.python-content}
```{.python}
def model():
    # Hardcoded parameter values
    interarrival_time = 5
    consultation_time = 20
    transfer_prob = 0.3
    # ...rest of the model...
```
:::

This makes it very difficult to change the values. Modellers might choose to...

**1. Edit parameters directly in the script**.

This involves manually changing parameter values in the script each time you want to run a new scenario. Problems with this approach include:

* ‚ùå **Not a reproducible analytical pipeline**. Alot of manual intervention is required to re-run the model with different parameters.
* ‚ùå **Error-prone**. It would be easy to make mistakes or forget to update all relevant values.
* ‚ùå **Parameters can get lost**. If you lost your notes or forget to record what you used, you won't know what values were used for past runs. 

**2. Duplicate scripts for each scenario**.

This involves copying the entire script, changing parameters in each copy, and running them separately. Problems with this approach include:

* ‚ùå **Code duplication**. This means any changes - like bug fixes or improvements to the model - must be made to every copy. This is tedious and there is a risk that some copies are missed or updated incorrectly.
* ‚ùå **Hard to keep track**. With multiple script copies, it can become difficult to know which scripts correspond to which scenarios, and which parameters were used (as have to delve into the model code to identify them).

<br>

## A slight improvement: global parameters

A better (but still limited) approach is to **define all parameters at the top of your script**:

They're no longer hard coded.
Can see what parameters were used, easier when changing.

::: {.python-content}
```{.python}
# Parameters for base case
INTERARRIVAL_TIME = 5
CONSULTATION_TIME = 20
TRANSFER_PROB = 0.3

def model():
    # Use the global parameters
    ...
```
:::

For scenarios, you would define the same global variables with alternative values:

::: {.python-content}
```{.python}
# Scenario 1
INTERARRIVAL_TIME = 6
CONSULTATION_TIME = 18
TRANSFER_PROB = 0.25
```
:::

The improvements are that:

* ‚úÖ **No longer hardcoded**. EXPLAIN WHY GOOD.
* ‚úÖ **Centralised**. All parameters are in one place, making them easier to find and change.

However, still several disadvantages:

* ‚ùå **Still inflexible**. In order to re-run the model with different scenarios, would still need to do the approaches above - editing code directly or duplicating scripts for each scenario.
* ‚ùå **Not scalable**. As the number of scenarios or parameters grows, managing all these global variables becomes messy. 

<br>

## Managing parameters in DES: two critical practices

To manage parameters effectively, you need **both**:

1. **Use a function or class to manage parameter sets**.
2. **Pass these objects explicitly to your model**.

want to pass direct to model as then

* no globals... can't bleed between scenarios... everything explicitly defined for each run

want to group parameters into dedicated objects

* have object that can call to view all param easily (e.g. in logs).
* can easily pass that object to model, reduce having loads of model inputs

could just use a dictionary but becomes a pain when have large number of param
e.g. just change one value, either rewrite dict, or copy dict and tweak that, but not an ideal approach

::: {.python-content}
```{.python}
base_params = {
    "interarrival_time": 5,
    "consultation_time": 20,
    "transfer_prob": 0.3,
    ...
}

scenario1 = base_params.copy()
scenario1["transfer_prob"] = 0.4
```
:::

so have two options: functions or classes
this is good. Full Reset: Easily reset all parameters to default values for each run. can easily tweak one or two param.

A function can generate parameter sets with defaults, allowing you to override only what‚Äôs needed

param are all in one place
easy to reset to defaults, see what base values are, not copying stuff

::: {.python-content}
```{.python}
def create_params(interarrival_time=5, consultation_time=20, transfer_prob=0.4):
    return {"interarrival_time": interarrival_time,
            "consultation_time": consultation_time,
            "transfer_prob": transfer_prob}

base_params = create_params()
scenario1 = create_params(interarrival_time=6)
scenario2 = create_params(transfer_prob=0.3)
```
:::

or can use class, store values in class itself, pass the class

::: {.python-content}
```{.python}
class Parameters:
    def __init__(self, a=3, b=12, c=50, d=0.1, e=20):
        self.a = a
        self.b = b
        self.c = c
        self.d = d
        self.e = e

    def __repr__(self):
        return f"Parameters(a={self.a}, b={self.b}, c={self.c}, d={self.d}, e={self.e})"

# Base case
base_params = Parameters()

# Scenario 1: Only change "a" and "d"
scenario1 = Parameters(a=5, d=0.2)

# Scenario 2: Only change "b"
scenario2 = Parameters(b=15)
```
:::

<br>

### Why you need both practices

If you only group parameters (but use globals), globals still cause issues, parameters might accidentally be modified elsewhere.

::: {.python-content}
```{.python}
# BAD: Parameters are grouped but still global
global_params = Parameters()

def simulate():
    # Uses global_params.interarrival_time... üò¨
    ...
```
:::

If you pass parameters (but don't group them), this is messy and error prone, too many arguments, hard to maintain.

::: {.python-content}
```{.python}
# BAD: Parameters are passed but disorganized
def simulate(interarrival_time, consultation_time, transfer_prob, ...):
    # 10+ parameters? Hard to track!
    ...
```
:::

<br>

## Bonus consideration:

the danger of not actually having behaviour expected for scenarios if use wrong parameter names.

can either check in the model function

or if you use class, can check direct there

<br>

## Full code

<details>
<summary>Show/Hide example 1: Nurse visit simulation</summary>


```{.bash}
touch simulation/model.py
```

```{.python}
# pylint: disable=too-many-instance-attributes,too-few-public-methods
class Param:
    """
    Default parameters for simulation.

    Attributes are described in initialisation docstring.
    """
    # pylint: disable=too-many-arguments,too-many-positional-arguments
    def __init__(
        self,
        patient_inter=4,
        mean_n_consult_time=10,
        number_of_nurses=5,
        warm_up_period=1440*27,  # 27 days
        data_collection_period=1440*30,  # 30 days
        number_of_runs=31,
        audit_interval=120,  # every 2 hours
        scenario_name=0,
        cores=-1,
        logger=SimLogger(log_to_console=False, log_to_file=False)
    ):
        """
        Initialise instance of parameters class.

        Arguments:
            patient_inter (float):
                Mean inter-arrival time between patients in minutes.
            mean_n_consult_time (float):
                Mean nurse consultation time in minutes.
            number_of_nurses (float):
                Number of available nurses.
            warm_up_period (int):
                Duration of the warm-up period in minutes - running simulation
                but not yet collecting results.
            data_collection_period (int):
                Duration of data collection period in minutes (also known as
                measurement interval) - which begins after any warm-up period.
            number_of_runs (int):
                The number of runs (i.e. replications), defining how many
                times to re-run the simulation (with different random numbers).
            audit_interval (int):
                How frequently to audit resource utilisation, in minutes.
            scenario_name (int|float|string):
                Label for the scenario.
            cores (int):
                Number of CPU cores to use for parallel execution. Set to
                desired number, or to -1 to use all available cores. For
                sequential execution, set to 1 (default).
            logger (logging.Logger):
                The logging instance used for logging messages.
        """
        # Disable restriction on attribute modification during initialisation
        object.__setattr__(self, '_initialising', True)

        self.patient_inter = patient_inter
        self.mean_n_consult_time = mean_n_consult_time
        self.number_of_nurses = number_of_nurses
        self.warm_up_period = warm_up_period
        self.data_collection_period = data_collection_period
        self.number_of_runs = number_of_runs
        self.audit_interval = audit_interval
        self.scenario_name = scenario_name
        self.cores = cores
        self.logger = logger

        # Re-enable attribute checks after initialisation
        object.__setattr__(self, '_initialising', False)

    def __setattr__(self, name, value):
        """
        Prevent addition of new attributes.

        This method overrides the default `__setattr__` behavior to restrict
        the addition of new attributes to the instance. It allows modification
        of existing attributes but raises an `AttributeError` if an attempt is
        made to create a new attribute. This ensures that accidental typos in
        attribute names do not silently create new attributes.

        Arguments:
            name (str):
                The name of the attribute to set.
            value (Any):
                The value to assign to the attribute.

        Raises:
            AttributeError:
                If `name` is not an existing attribute and an attempt is made
                to add it to the instance.
        """
        # Skip the check if the object is still initialising
        # pylint: disable=maybe-no-member
        if hasattr(self, '_initialising') and self._initialising:
            super().__setattr__(name, value)
        else:
            # Check if attribute of that name is already present
            if name in self.__dict__:
                super().__setattr__(name, value)
            else:
                raise AttributeError(
                    f'Cannot add new attribute "{name}" - only possible to ' +
                    f'modify existing attributes: {self.__dict__.keys()}')
```

</details>

---

<details>
<summary>Show/Hide example 2: stroke pathway simulation</summary>


Make file.

```{.bash}
touch simulation/parameters.py
```

Copy in.

```{.python}
"""
Stroke pathway simulation parameters.

It includes arrival rates, length of stay distributions, and routing
probabilities between different care settings.
"""

from simulation.logging import SimLogger


class RestrictAttributesMeta(type):
    """
    Metaclass for attribute restriction.

    A metaclass modifies class construction. It intercepts instance creation
    via __call__, adding the _initialised flag after __init__ completes. This
    is later used by RestrictAttributes to enforce attribute restrictions.
    """
    def __call__(cls, *args, **kwargs):
        # Create instance using the standard method
        instance = super().__call__(*args, **kwargs)
        # Set the "_initialised" flag to True, marking end of initialisation
        instance.__dict__["_initialised"] = True
        return instance


class RestrictAttributes(metaclass=RestrictAttributesMeta):
    """
    Base class that prevents the addition of new attributes after
    initialisation.

    This class uses RestrictAttributesMeta as its metaclass to implement
    attribute restriction. It allows for safe initialisation of attributes
    during the __init__ method, but prevents the addition of new attributes
    afterwards.

    The restriction is enforced through the custom __setattr__ method, which
    checks if the attribute already exists before allowing assignment.
    """
    def __setattr__(self, name, value):
        """
        Prevent addition of new attributes.

        Parameters
        ----------
        name: str
            The name of the attribute to set.
        value: any
            The value to assign to the attribute.

        Raises
        ------
        AttributeError
            If `name` is not an existing attribute and an attempt is made
            to add it to the class instance.
        """
        # Check if the instance is initialised and the attribute doesn"t exist
        if hasattr(self, "_initialised") and not hasattr(self, name):
            # Get a list of existing attributes for the error message
            existing = ", ".join(self.__dict__.keys())
            raise AttributeError(
                f"Cannot add new attribute '{name}' - only possible to " +
                f"modify existing attributes: {existing}."
            )
        # If checks pass, set the attribute using the standard method
        object.__setattr__(self, name, value)


class ASUArrivals(RestrictAttributes):
    """
    Arrival rates for the acute stroke unit (ASU) by patient type.

    These are the average time intervals (in days) between new admissions.
    For example, a value of 1.2 means a new admission every 1.2 days.
    """
    def __init__(self, stroke=1.2, tia=9.3, neuro=3.6, other=3.2):
        """
        Parameters
        ----------
        stroke: float
            Stroke patient.
        tia: float
            Transient ischaemic attack (TIA) patient.
        neuro: float
            Complex neurological patient.
        other: float
            Other patient types (including medical outliers).
        """
        self.stroke = stroke
        self.tia = tia
        self.neuro = neuro
        self.other = other


class RehabArrivals(RestrictAttributes):
    """
    Arrival rates for the rehabiliation unit by patient type.

    These are the average time intervals (in days) between new admissions.
    For example, a value of 21.8 means a new admission every 21.8 days.
    """
    def __init__(self, stroke=21.8, neuro=31.7, other=28.6):
        """
        Parameters
        ----------
        stroke: float
            Stroke patient.
        neuro: float
            Complex neurological patient.
        other: float
            Other patient types.
        """
        self.stroke = stroke
        self.neuro = neuro
        self.other = other


class ASULOS(RestrictAttributes):
    """
    Mean and standard deviation (SD) of length of stay (LOS) in days in the
    acute stroke unit (ASU) by patient type.

    Attributes
    ----------
    stroke_noesd: dict
        Mean and SD of LOS for stroke patients without early support discharge.
    stroke_esd: dict
        Mean and SD of LOS for stroke patients with early support discharge.
    tia: dict
        Mean and SD of LOS for transient ischemic attack (TIA) patients.
    neuro: dict
        Mean and SD of LOS for complex neurological patients.
    other: dict
        Mean and SD of LOS for other patients.
    """
    def __init__(
        self,
        stroke_no_esd_mean=7.4, stroke_no_esd_sd=8.61,
        stroke_esd_mean=4.6, stroke_esd_sd=4.8,
        tia_mean=1.8, tia_sd=2.3,
        neuro_mean=4.0, neuro_sd=5.0,
        other_mean=3.8, other_sd=5.2
    ):
        """
        Parameters
        ----------
        stroke_no_esd_mean: float
            Mean LOS for stroke patients without early support discharge (ESD)
            services.
        stroke_no_esd_sd: float
            SD of LOS for stroke patients without ESD.
        stroke_esd_mean: float
            Mean LOS for stroke patients with ESD.
        stroke_esd_sd: float
            SD of LOS for stroke patients with ESD.
        tia_mean: float
            Mean LOS for TIA patients.
        tia_sd: float
            SD of LOS for TIA patients.
        neuro_mean: float
            Mean LOS for complex neurological patients.
        neuro_sd: float
            SD of LOS for complex neurological patients.
        other_mean: float
            Mean LOS for other patient types.
        other_sd: float
            SD of LOS for other patient types.
        """
        self.stroke_noesd = {
            "mean": stroke_no_esd_mean,
            "sd": stroke_no_esd_sd
        }
        self.stroke_esd = {
            "mean": stroke_esd_mean,
            "sd": stroke_esd_sd
        }
        self.tia = {
            "mean": tia_mean,
            "sd": tia_sd
        }
        self.neuro = {
            "mean": neuro_mean,
            "sd": neuro_sd
        }
        self.other = {
            "mean": other_mean,
            "sd": other_sd
        }


class RehabLOS(RestrictAttributes):
    """
    Mean and standard deviation (SD) of length of stay (LOS) in days in the
    rehabilitation unit by patient type.

    Attributes
    ----------
    stroke_noesd: dict
        Mean and SD of LOS for stroke patients without early support discharge.
    stroke_esd: dict
        Mean and SD of LOS for stroke patients with early support discharge.
    tia: dict
        Mean and SD of LOS for transient ischemic attack (TIA) patients.
    neuro: dict
        Mean and SD of LOS for complex neurological patients.
    other: dict
        Mean and SD of LOS for other patients.
    """
    def __init__(
        self,
        stroke_no_esd_mean=28.4, stroke_no_esd_sd=27.2,
        stroke_esd_mean=30.3, stroke_esd_sd=23.1,
        tia_mean=18.7, tia_sd=23.5,
        neuro_mean=27.6, neuro_sd=28.4,
        other_mean=16.1, other_sd=14.1
    ):
        """
        Parameters
        ----------
        stroke_no_esd_mean: float
            Mean LOS for stroke patients without early support discharge (ESD)
            services.
        stroke_no_esd_sd: float
            SD of LOS for stroke patients without ESD.
        stroke_esd_mean: float
            Mean LOS for stroke patients with ESD.
        stroke_esd_sd: float
            SD of LOS for stroke patients with ESD.
        tia_mean: float
            Mean LOS for TIA patients.
        tia_sd: float
            SD of LOS for TIA patients.
        neuro_mean: float
            Mean LOS for complex neurological patients.
        neuro_sd: float
            SD of LOS for complex neurological patients.
        other_mean: float
            Mean LOS for other patient types.
        other_sd: float
            SD of LOS for other patient types.
        """
        self.stroke_noesd = {
            "mean": stroke_no_esd_mean,
            "sd": stroke_no_esd_sd
        }
        self.stroke_esd = {
            "mean": stroke_esd_mean,
            "sd": stroke_esd_sd
        }
        self.tia = {
            "mean": tia_mean,
            "sd": tia_sd
        }
        self.neuro = {
            "mean": neuro_mean,
            "sd": neuro_sd
        }
        self.other = {
            "mean": other_mean,
            "sd": other_sd
        }


class ASURouting(RestrictAttributes):
    """
    Probabilities of each patient type being transferred from the acute
    stroke unit (ASU) to other destinations.

    Attributes
    ----------
    stroke: dict
        Routing probabilities for stroke patients.
    tia: dict
        Routing probabilities for transient ischemic attack (TIA) patients.
    neuro: dict
        Routing probabilities for complex neurological patients.
    other: dict
        Routing probabilities for other patients.
    """
    def __init__(
        self,
        # Stroke patients
        stroke_rehab=0.24, stroke_esd=0.13, stroke_other=0.63,
        # TIA patients
        tia_rehab=0.01, tia_esd=0.01, tia_other=0.98,
        # Complex neurological patients
        neuro_rehab=0.11, neuro_esd=0.05, neuro_other=0.84,
        # Other patients
        other_rehab=0.05, other_esd=0.10, other_other=0.85
    ):
        """
        Parameters
        ----------
        stroke_rehab: float
            Stroke patient to rehabilitation unit.
        stroke_esd: float
            Stroke patient to early support discharge (ESD) services.
        stroke_other: float
            Stroke patient to other destinations (e.g., own home, care
            home, mortality).
        tia_rehab: float
            TIA patient to rehabilitation unit.
        tia_esd: float
            TIA patient to ESD.
        tia_other: float
            TIA patient to other destinations.
        neuro_rehab: float
            Complex neurological patient to rehabilitation unit.
        neuro_esd: float
            Complex neurological patient to ESD.
        neuro_other: float
            Complex neurological patient to other destinations.
        other_rehab: float
            Other patient type to rehabilitation unit.
        other_esd: float
            Other patient type to ESD.
        other_other: float
            Other patient type to other destinations.
        """
        self.stroke = {
            "rehab": stroke_rehab,
            "esd": stroke_esd,
            "other": stroke_other
        }
        self.tia = {
            "rehab": tia_rehab,
            "esd": tia_esd,
            "other": tia_other
        }
        self.neuro = {
            "rehab": neuro_rehab,
            "esd": neuro_esd,
            "other": neuro_other
        }
        self.other = {
            "rehab": other_rehab,
            "esd": other_esd,
            "other": other_other
        }


class RehabRouting(RestrictAttributes):
    """
    Probabilities of each patient type being transferred from the rehabiliation
    unit to other destinations.

    Attributes
    ----------
    stroke: dict
        Routing probabilities for stroke patients.
    tia: dict
        Routing probabilities for transient ischemic attack (TIA) patients.
    neuro: dict
        Routing probabilities for complex neurological patients.
    other: dict
        Routing probabilities for other patients.
    """
    def __init__(
        self,
        # Stroke patients
        stroke_esd=0.40, stroke_other=0.60,
        # TIA patients
        tia_esd=0, tia_other=1,
        # Complex neurological patients
        neuro_esd=0.09, neuro_other=0.91,
        # Other patients
        other_esd=0.13, other_other=0.88
    ):
        """
        Parameters
        ----------
        stroke_esd: float
            Stroke patient to early support discharge (ESD) services.
        stroke_other: float
            Stroke patient to other destinations (e.g., own home, care home,
            mortality).
        tia_esd: float
            TIA patient to ESD.
        tia_other: float
            TIA patient to other destinations.
        neuro_esd: float
            Complex neurological patient to ESD.
        neuro_other: float
            Complex neurological patient to other destinations.
        other_esd: float
            Other patient type to ESD.
        other_other: float
            Other patient type to other destinations.
        """
        self.stroke = {
            "esd": stroke_esd,
            "other": stroke_other
        }
        self.tia = {
            "esd": tia_esd,
            "other": tia_other
        }
        self.neuro = {
            "esd": neuro_esd,
            "other": neuro_other
        }
        self.other = {
            "esd": other_esd,
            "other": other_other
        }


class Param(RestrictAttributes):
    """
    Default parameters for simulation.
    """
    def __init__(
        self,
        asu_arrivals=ASUArrivals(),
        rehab_arrivals=RehabArrivals(),
        asu_los=ASULOS(),
        rehab_los=RehabLOS(),
        asu_routing=ASURouting(),
        rehab_routing=RehabRouting(),
        warm_up_period=365*3,  # 3 years
        data_collection_period=365*5,  # 5 years
        number_of_runs=150,
        audit_interval=1,
        cores=1,
        log_to_console=False,
        log_to_file=False
    ):
        """
        Initialise a parameter set for the simulation.

        Parameters
        ----------
        asu_arrivals: ASUArrivals
            Arrival rates to the acute stroke unit (ASU) in days.
        rehab_arrivals: RehabArrivals
            Arrival rates to the rehabilitation unit in days.
        asu_los: ASULOS
            Length of stay (LOS) distributions for patients in the ASU in days.
        rehab_los: RehabLOS
            LOS distributions for patients in the rehabilitation unit in days.
        asu_routing: ASURouting
            Transfer probabilities from the ASU to other destinations.
        rehab_routing: RehabRouting
            Transfer probabilities from the rehabilitation unit to other
            destinations.
        warm_up_period: int
            Length of the warm-up period.
        data_collection_period: int
            Length of the data collection period.
        number_of_runs: int
            The number of runs (i.e. replications), defining how many times to
            re-run the simulation (with different random numbers).
        audit_interval: float
            Frequency of simulation audits in days.
        cores: int
            Number of CPU cores to use for parallel execution. Set to desired
            number, or to -1 to use all available cores. For sequential
            execution, set to 1.
        log_to_console: boolean
            Whether to print log messages to the console.
        log_to_file: boolean
            Whether to save log to a file.
        """
        # Set parameters
        self.asu_arrivals = asu_arrivals
        self.rehab_arrivals = rehab_arrivals
        self.asu_los = asu_los
        self.rehab_los = rehab_los
        self.asu_routing = asu_routing
        self.rehab_routing = rehab_routing
        self.warm_up_period = warm_up_period
        self.data_collection_period = data_collection_period
        self.number_of_runs = number_of_runs
        self.audit_interval = audit_interval
        self.cores = cores

        # Set up logger
        self.logger = SimLogger(log_to_console=log_to_console,
                                log_to_file=log_to_file)

    def check_param_validity(self):
        """
        Check the validity of the provided parameters.

        Validates all simulation parameters to ensure they meet requirements:
        - Warm-up period and data collection period must be >= 0
        - Number of runs and audit interval must be > 0
        - Arrival rates must be >= 0
        - Length of stay parameters must be >= 0
        - Routing probabilities must sum to 1 and be between 0 and 1

        Raises
        ------
        ValueError
            If any parameter fails validation with a descriptive error message.
        """
        # Validate parameters that must be >= 0
        for param in ["warm_up_period", "data_collection_period"]:
            self.validate_param(
                param, lambda x: x >= 0,
                "must be greater than or equal to 0")

        # Validate parameters that must be > 0
        for param in ["number_of_runs", "audit_interval"]:
            self.validate_param(
                param, lambda x: x > 0,
                "must be greater than 0")

        # Validate arrival parameters
        for param in ["asu_arrivals", "rehab_arrivals"]:
            self.validate_nested_param(
                param, lambda x: x >= 0,
                "must be greater than 0")

        # Validate length of stay parameters
        for param in ["asu_los", "rehab_los"]:
            self.validate_nested_param(
                param, lambda x: x >= 0,
                "must be greater than 0", nested=True)

        # Validate routing parameters
        for param in ["asu_routing", "rehab_routing"]:
            self.validate_routing(param)

    def validate_param(self, param_name, condition, error_msg):
        """
        Validate a single parameter against a condition.

        Parameters
        ----------
        param_name: str
            Name of the parameter being validated.
        condition: callable
            A function that returns True if the value is valid.
        error_msg: str
            Error message to display if validation fails.

        Raises
        ------
        ValueError:
            If the parameter fails the validation condition.
        """
        value = getattr(self, param_name)
        if not condition(value):
            raise ValueError(
                f"Parameter '{param_name}' {error_msg}, but is: {value}")

    def validate_nested_param(
        self, obj_name, condition, error_msg, nested=False
    ):
        """
        Validate parameters within a nested object structure.

        Parameters
        ----------
        obj_name: str
            Name of the object containing parameters.
        condition: callable
            A function that returns True if the value is valid.
        error_msg: str
            Error message to display if validation fails.
        nested: bool, optional
            If True, validates parameters in a doubly-nested structure. If
            False, validates parameters in a singly-nested structure.

        Raises
        ------
        ValueError:
            If any nested parameter fails the validation condition.
        """
        obj = getattr(self, obj_name)
        for key, value in vars(obj).items():
            if key == "_initialised":
                continue
            if nested:
                for sub_key, sub_value in value.items():
                    if not condition(sub_value):
                        raise ValueError(
                            f"Parameter '{sub_key}' for '{key}' in " +
                            f"'{obj_name}' {error_msg}, but is: {sub_value}")
            else:
                if not condition(value):
                    raise ValueError(
                        f"Parameter '{key}' from '{obj_name}' {error_msg}, " +
                        f"but is: {value}")

    def validate_routing(self, obj_name):
        """
        Validate routing probability parameters.

        Performs two validations:
        1. Checks that all probabilities for each routing option sum to 1.
        2. Checks that individual probabilities are between 0 and 1 inclusive.

        Parameters
        ----------
        obj_name: str
            Name of the routing object.

        Raises
        ------
        ValueError:
            If the probabilities don't sum to 1, or if any probability is
            outside [0,1].
        """
        obj = getattr(self, obj_name)
        for key, value in vars(obj).items():
            if key == "_initialised":
                continue

            # Check that probabilities sum to 1
            # Note: In the article, rehab other is 88% and 13%, so have
            # allowed deviation of 1%
            total_prob = sum(value.values())
            if total_prob < 0.99 or total_prob > 1.01:
                raise ValueError(
                    f"Routing probabilities for '{key}' in '{obj_name}' " +
                    f"should sum to apx. 1 but sum to: {total_prob}")

            # Check that probabilities are between 0 and 1
            for sub_key, sub_value in value.items():
                if sub_value < 0 or sub_value > 1:
                    raise ValueError(
                        f"Parameter '{sub_key}' for '{key}' in '{obj_name}'" +
                        f"must be between 0 and 1, but is: {sub_value}")

```

</details>

---