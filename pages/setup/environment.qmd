# Dependency management {#sec-environment}

{{< include ../../scripts/language-selector.html >}}

> @sec-guidelines:
>
> * Heather et al. 2025: List dependencies and versions.
> * NHS Levels of RAP (ðŸ¥ˆ): Repository includes dependency information.

Dependency management is about keeping track of the environment used for your project. This includes the version of your programming languages, any packages used, and their versions.

It acts like a **time capsule**, allowing you to return to a project later and run it with the exact same packages and versions, reproducing the results generated previously.

![](environment_files/time_capsule.png)

Dependency management enables you to **isolate environments for different projects**. Each project can have it's own set of dependencies, preventing conflicts and making it easy to switch between projects.

![](environment_files/isolated_env.png)

It is also important for **collaboration**, so that everyone working on the project is using the same environment.

![](environment_files/collaborate.png)

<!--TODO: these illustrations are very rough. keep? if so, redo much cleaner? make it consistent imagery - brown box - so the three project envs are three brown boxes - and the two little people are holding brown boxes-->

<br>

:::{.python-content}
## Python tools for dependency management

There are lots of tools available for managing dependencies in isolated environments in python. A few of the most popular tools include **venv**, **conda**, and **poetry**.

In this book, we will use **conda**, as it allows us to **specify a python version**, so each environment we create can have a different specific version of python. This is not possible with venv and poetry, which just manage the package dependencies, and will just use the system python.

::: {.callout-note}

## Mamba

**Mamba** is a drop-in replacement for conda that is often preferred as it is:

* Faster than conda.
* Better at dealing with dependency conflicts, providing more helpful messages in cases where environments fail to builds due to clashing requirements of different packages.

To use mamba, simply replace `conda` in all the commands below with `mamba`.

:::

<br>

## Installing conda (or mamba)

Refer to the conda or mamba documentation for the latest instructions on installing these for your operating system (windows, mac or linux).

* [Conda installation instructions](https://docs.conda.io/projects/conda/en/latest/user-guide/install/index.html).
* [Mamba installation instructions](https://mamba.readthedocs.io/en/latest/installation/mamba-installation.html).

<br>

## Setting up our conda environment

**1. Create an environment file.** In the project root, we create ðŸ“„`environment.yaml`.

```{.bash}
touch environment.yaml
```

Within this file, we add three sections:

* **Name**. The environment name.
* **Channels**. Where to find packages (e.g. `conda-forge`). <!--TODO: explain about options here, and why we chose conda-forge-->
* **Dependencies**. The packages you need.

When first creating our environment, we just list the dependencies we know we need at this point - we can always add more later! At the start of a project, you might only know one: python.

As an example, we will add `simpy` and python.

```{.bash}
name: des-example
channels:
  - conda-forge
dependencies:
  - python
  - simpy
```

<br>

**2. Build and activate the environment**. In the command line, run the following to create your environment:

```{.bash}
conda env create --file environment.yaml
```

You can then activate it (replacing `des-example` with your environment name):

```{.bash}
conda activate des-example
```

To confirm your environment contains the expected packages, run:

```{.bash}
conda list
```

This will output a list of packages, versions, builds and channels. For example, it may look similar to:

```
(des-example) amy@xps:~/Documents/hospital-des$ conda list
# packages in environment at /home/amy/mambaforge/envs/des-example:
#
# Name                    Version                   Build  Channel
_libgcc_mutex             0.1                 conda_forge    conda-forge
_openmp_mutex             4.5                       2_gnu    conda-forge
bzip2                     1.0.8                h4bc722e_7    conda-forge
ca-certificates           2025.1.31            hbd8a1cb_1    conda-forge
ld_impl_linux-64          2.43                 h712a8e2_4    conda-forge
libexpat                  2.7.0                h5888daf_0    conda-forge
libffi                    3.4.6                h2dba641_1    conda-forge
libgcc                    14.2.0               h767d61c_2    conda-forge
libgcc-ng                 14.2.0               h69a702a_2    conda-forge
libgomp                   14.2.0               h767d61c_2    conda-forge
liblzma                   5.8.1                hb9d3cd8_0    conda-forge
libmpdec                  4.0.0                h4bc722e_0    conda-forge
libsqlite                 3.49.1               hee588c1_2    conda-forge
libuuid                   2.38.1               h0b41bf4_0    conda-forge
libzlib                   1.3.1                hb9d3cd8_2    conda-forge
ncurses                   6.5                  h2d0b736_3    conda-forge
openssl                   3.5.0                h7b32b05_0    conda-forge
pip                       25.0.1             pyh145f28c_0    conda-forge
python                    3.13.3          hf636f53_101_cp313    conda-forge
python_abi                3.13                    7_cp313    conda-forge
readline                  8.2                  h8c095d6_2    conda-forge
simpy                     4.1.1              pyhd8ed1ab_1    conda-forge
tk                        8.6.13          noxft_h4845f30_101    conda-forge
tzdata                    2025b                h78e105d_0    conda-forge
```

<br>

**3. Specify versions**. For reproducibility, it's best to specify the exact package versions in you `environment.yaml`. If you're starting from scratch, you may not know which versions you need, so you can leave them out initially, as we did in step 1.

However, now that we have built our environment (which used the latest versions as none were specified), it is important to then record your versions in the ðŸ“„`environment.yaml`. These are the versions you saw when running `conda list`. For example:

```{.bash}
name: des-example
channels:
  - conda-forge
dependencies:
  - python=3.13.3
  - simpy=4.1.1
```

<br>

**4. Setting up the full environment for this book.** When working on a project from scratch, you will often build up your environment organically and iteratively as you find more packages you want to use. However, to follow along with this book and ensure everything works as expected, you can use the full environment provided below. Copy this into your ðŸ“„`environment.yaml` (feel free to alter the name!):

```{.bash}
name: des-example
channels:
  - conda-forge
dependencies:
  - ipykernel=6.29.5
  - jinja2=3.1.5
  - joblib=1.4.2
  - nbconvert=7.16.6
  - nbformat=5.10.4
  - nbqa=1.9.0
  - numpy=2.2.2
  - pandas=2.2.3
  - pip=25.0
  - plotly_express=0.4.1
  - pylint=3.3.4
  - pytest=8.3.4
  - pytest-xdist=3.6.1
  - python=3.13.1
  - rich=13.9.4
  - simpy=4.1.1
  - pip:
    - kaleido==0.2.1
    - sim-tools==0.8.0
```

Then update your environment to include these packages (after running `conda activate des-example`) with:

```{.bash}
conda env update --file environment.yaml --prune
```



<!-- either make full section explaining that need to check run etc, or remove
::: {.callout-note}

## Updating packages

If want to update all your packages, you can run:

```{.bash}
conda update --all
```

If you do this, make sure to update the `environment.yaml` to reflect these changes.

:::
-->

<br>

### Further information

* ["An unbiased evaluation of environment management and packaging tools"](https://alpopkes.com/posts/python/packaging_tools/) from Anna-Lena Popkes 2024
* ["Python dependency management is a dumpster fire"](https://nielscautaerts.xyz/python-dependency-management-is-a-dumpster-fire.html) from Niels Cautaerts 2024

:::

:::{.r-content}
## R tools for dependency management

The most popular tool for managing dependencies in R is **renv**. This replaced and improved upon the previous tool, **Packrat**.

Renv will create isolated environments with the specific packages and their versions for a project. However, it **won't manage the version of R used** - the version of R used is simply whatever is installed on your system.
<!--TODO: add note about how to switch R versions... explain why this matters -->
<!--TODO: mention operating system issues...-->
<!--TODO: had wanted to explore rig... thoughts... anything to mention here on other tools...?-->

<br>

## Setting up renv

**1. Make the repository an R project**. Renv is designed to work nicely with R projects. A project is just a directory containing an `.Rproj` file, as well as a hidden directory `.Rproj.user`. These can be created in RStudio by selecting "File > New Project...". A box will appear, from which you should select "Existing Directory".

![](environment_files/rproject1.png)

You then to navigate to your directory using the file browser, and select "Create Project".

![](environment_files/rproject2.png)

RStudio will refresh, and you should then find that your directory now contains an `.Rproj` file and `.Rproj.user/` hidden folder. It will look something like this:

```{.bash}
our_directory/
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .Rproj.user/         # New
â”‚   â””â”€â”€ ...
â”œâ”€â”€ LICENSE
â”œâ”€â”€ our_directory.Rproj  # New
â””â”€â”€ README.md
```

:::{.callout-note}

## Using renv without RStudio or `.Rproj`

R projects are commonly created and managed by RStudio. If you are not using RStudio, they can be difficult to set-up, as they have to be created manually.

However, it is possible to use renv without an R project, as discussed in [this GitHub issue](https://github.com/rstudio/renv/issues/460). This can be done by using `setwd()` to set your repository as the current working directory, and then continuing with the steps below, running `renv::init()`.

:::

<br>

**2. Initialise renv**. To get started with `renv`, run the following command in your R console:

```{.r}
renv::init()
```

This will create three new files and folders:

* `renv/library/`: stores packages used in project - at this point, it will just list R and `renv`.
* `renv.lock`: record of packages used, so they can be re-installed on a new machine.
* `.Rprofile`: ensures that renv is activated when open project - just contains one line, `source("renv/activate.R")`.

Your directory should now look something like this:

```{.bash}
our_directory/
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .Rprofile  # New
â”œâ”€â”€ .Rproj.user/
â”‚   â””â”€â”€ ...
â”œâ”€â”€ LICENSE
â”œâ”€â”€ our_directory.Rproj
â””â”€â”€ README.md
â”œâ”€â”€ renv/      # New
â”‚   â””â”€â”€ ...
â””â”€â”€ renv.lock  # New
```

<br>

With `renv` initialised, you will now have an empty project library, just containing `renv`, as you can see from viewing `renv.lock` (example below). This is isolated from your previous projects, and from here, you can install the packages relevant for your current project.

Example `renv.lock`:

```
{
  "R": {
    "Version": "4.4.1",
    "Repositories": [
      {
        "Name": "CRAN",
        "URL": "https://packagemanager.posit.co/cran/latest"
      }
    ]
  },
  "Packages": {
    "renv": {
      "Package": "renv",
      "Version": "1.0.7",
      "Source": "Repository",
      "Repository": "CRAN",
      "Requirements": [
        "utils"
      ],
      "Hash": "397b7b2a265bc5a7a06852524dabae20"
    }
  }
}

```

<br>

## Adding packages to the environment

### Explanation of approaches to adding packages

When adding packages to an `renv`, there are two approaches you can take:

* **Direct installation**: Manually install packages into your project environment using `renv::install("packagename")` or `install.packages("packagename").
* **DESCRIPTION file**: List your dependencies in a `DESCRIPTION` file (as you would when developing an R package) and let `renv` everything declared there.

We recommend using a `DESCRIPTION` file. The advantages of this are:

* **Explicit declaration.** 

**1. Create a DESCRIPTION file**. You can easily create a `DESCRIPTION` file from scratch. Create a blank file called `DESCRIPTION` by executing this command in your terminal:

```
touch DESCRIPTION
```

Then open the file and copy in this template:

```
Package: packagename
Title: What the Package Does (One Line, Title Case)
Version: 0.0.0.9000
Authors@R: 
    person("First", "Last", , "first.last@example.com", role = c("aut", "cre"))
Description: What the package does (one paragraph).
License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a
    license
Encoding: UTF-8
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.0.0
```

You can alter some of the meta-data in this file - for example:

```
Package: hospital-des-r
Title: Hospital DES R
Version: 0.0.0.9000
Authors@R: 
    person("Amy", "Heather", , "a.heather2@exeter.ac.uk", role = c("aut", "cre"))
Description: Hospital discrete-event simulation in R.
License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a
    license
Encoding: UTF-8
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.0.0
```

:::{.callout-note}

This is a standard template. You can create an identical file with `usethis` by running `usethis::use_description()`. However, we can just create it from scratch, which helps to minimise our dependencies (although you may later find you want to install `usethis` for other functionalities, such as in @sec-package). <!--TODO: check if i mention usethis in package page... if not, just change to be more general, if making a package.-->

:::

<br>

**2. List dependencies**. In a `DESCRIPTION` file, dependencies are listed under two headings: `Imports` or `Suggests`. `Imports` are required for the project to run, whilst `Suggests` are packages just needed for development, testing or optional features.

For most projects (especially non-packages), it's fine to just list all your dependencies under `Imports` for simplicity. The distinction betweeen `Imports` and `Suggests` is more relevant when constructing your research as an R package, as it distinguishes between those necessary for the core simulation and those for other analysis and tests.

As an example, at the start of your project, your `DESCRIPTION` could just list your simulation package - in this case, `simmer`. As you progressed with your project, you would then just **iteratively add new dependencies** to `DESCRIPTION`.

```{.r}
Imports:
    simmer
```

If you are following along with this book, the following `DESCRIPTION` will provide all the packages necessary to run the code provided:

```{.r}
Imports:
    simmer,
    magrittr,
    dplyr,
    purrr,
    rlang,
    tidyr,
    tidyselect,
    future,
    future.apply,
    ggplot2,
    tibble,
    gridExtra,
    R6
Suggests:
    testthat (>= 3.0.0),
    patrick,
    lintr,
    devtools,
    xtable,
    data.table,
    mockery
Config/testthat/edition: 3
```

<br>

**3. Install the packages**. In your R console, run:

```{.r}
renv::install()
```

This will identifies the packages listed in `DESCRIPTION` and install them (and their dependencies) into your environment.

<br>

## Making a record of your environment

In `renv`, we can make a record of all the dependencies (and their versions) from our environment using the `renv::snapshot()` command. This is important for providing a clear record of your working environment. There are three snapshot types:

* **Implicit** - records any packages (and their dependencies) listed in `DESCRIPTION` or used in your code.
* **Explicit** - only records packages (and their dependencies) listed in `DESCRIPTION`.
* **All** - records all packages in your environment.

The default snapshot type is **implicit**, and we recommend this approach. This is because it will catch any packages you are using but that you have forgot to add to `DESCRIPTION` (although it is best to remember to record these in `DESCRIPTION`, so you have a nice clear list of packages, and don't have to delve into `renv.lock` if you're having issues).

The downside to this snapshot type if that it may include unnecessary packages if you include old scripts in your repository that use packages you no longer need. However, this can be avoided by removing old scripts (good practice!).

<br>

**1. Check your snapshot type**. To check your current type, run this command in the R console:

```{.r}
renv::settings$snapshot.type()
```

If you want to change it, then run one of:

```{.r}
renv::settings$snapshot.type("implicit")
renv::settings$snapshot.type("explicit")
renv::settings$snapshot.type("all")
```

<br>

**2. Take a snapshot**. To take a snapshot of your environment and update your `renv.lock` file, run:

```{.r}
renv::snapshot()
```

<br>

## Recreating an existing environment

You may wish to recreate an existing environment - such as from an old project, or collaborators on your project, or etc.

You can do so based on either the `renv.lock` file or the `DESCRIPTION` file.

<br>

### Rebuilding environment from `renv.lock`

If you have both available, then try with the `renv.lock` in the first instance, as this will have the exact packages and versions used.

To do so, simply run:

```{.r}
renv::restore()
```

However, you may run into issues - more likely with an older or longer `renv.lock` file - in all the exact versions used. There can be conflicts or issues, such as due to varying operating systems...

<br>

### Rebuilding environment from `DESCRIPTION`

As an alternative, the `DESCRIPTION` file can then be used to install packages, by running:

```{.r}
renv::install()
```

This is just as we did above, where I provided a list of packages required to run the code in this book.

<!--TODO: need to explain about differences in versions with this... DESCRIPTION with versions... DESCRIPTION without versions... what the differences are...-->

<!--TODO: add note about how in r, working with specific r and packages, bit different to python, bit harder, suppoesdly forwards compatabile but no guarantee, often way of working is building a new env based on known packages, and backdating versions if something not working because of that... but also you can direct reuse an renv, as below, just check same version of r and so on, and other stuff, its not super simple-->

<br>

## Reason for the approach used above

<!--TODO: this duplicates above... but i think nice to mention as i only walk through description like its the only way and i need to be clear it is not...-->
There are two approaches to adding packages:

* Directly installing them using `renv::install("packagename")` or `install.packages("packagename")`.
* Listing packages in a `DESCRIPTION` file then calling `renv::install()`.

This tutorial used a `DESCRIPTION` file is that it allows you to create a clear, user-readable list of the main packages needed for your project.

Although they are typically associated with creating a package (see @sec-package), they can also come in handy just for dependency management.

This is because `renv` will record the packages necessary for a project in a file called `renv.lock`. However, as this contains all the packages *and* their dependencies, it can be very long and full of different packages.

If users later struggle restore the environment from the `renv.lock`, it is very handy to have a seperate list of dependencies in `DESCRIPTION` which they can base a new environment on, helping to resolve conflicts.

<br>

## System dependencies

Some R packages required external system libraries. The exact requirements will depend on which packages you use, what operating system you have, and whether you have used R before.

For example, working on Ubuntu, we found that we had to install the following system dependencies for `igraph`:

```{.bash}
sudo apt install build-essential gfortran
sudo apt install libglpk-dev libxml2-dev
```

:::