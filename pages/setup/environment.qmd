---
title: Dependency management
---

:::{.guidelines}
* Heather et al. 2025: List dependencies and versions.
* NHS Levels of RAP (ðŸ¥ˆ): Repository includes dependency information.
:::

Dependency management is about keeping track of the environment used for your project. This includes the version of your programming languages, any packages used, and their versions.

It acts like a **time capsule**, allowing you to return to a project later and run it with the exact same packages and versions, reproducing the results generated previously.

![](environment_resources/time_capsule.png)

Dependency management enables you to **isolate environments for different projects**. Each project can have it's own set of dependencies, preventing conflicts and making it easy to switch between projects.

![](environment_resources/isolated_env.png)

It is also important for **collaboration**, so that everyone working on the project is using the same environment.

![](environment_resources/collaborate.png){fig-align="center" width=80%}

<br>

## Tools for dependency management

::::{.python-content}

There are several popular tools for managing Python dependencies in isolated environment. Below, we compare some of main options, and consider some of the main factors that may influence your choice:

* **Python version management:** Can the tool install and switch between different Python versions? This is crucial for projects that require specific versions.
* **Default environment location:** Does the tool create environments in the project folder or in a central location? Central locations can be reused across multiple repositories from a single project, while repository-specific environments keep everything together.
* **Speed:** How fast does the tool create environments and install packages?
* **Build and publish packages:** If you are [structuring your research as a package](package.qmd), you may wish to use one tool - or separate tools - for dependency management and creation of your package.

Other details like the package source (where packages come from) and config files (which files list dependencies) are also included.

<br>

| **venv** (2012)
| <https://docs.python.org/3/library/venv.html>
`venv` was introduced with Python 3.3, and quickly replaced `pyvenv` and `virtualenv` as the standard way of managing virtual environments. It is included as part of the standard Python library, and so requires no installation.

::: {.table-greycol}
| Feature | venv |
| -- | --- |
| Manages different python versions | No (uses the Python version it was invoked with) |
| Default env location | Project directory (e.g. `./venv`) |
| Customise location? | Yes |
| Default package source | PyPI |
| Config file | `requirements.txt` |
| Speed | Fast |
| Build and publish packages? | No |
:::

<br>

| **conda** (2012)
| <https://github.com/conda/conda>
`conda` comes with Anaconda and Miniconda or can be installed separately. It can install and manage multiple Python versions, and non-Python dependencies (e.g. R, Node.js, compilers and system libraries). `mamba` (2020) is a drop-in replacement for conda written in C++ which offers faster installs and clearer conflict messages.

::: {.table-greycol}
| Feature | conda |
| -- | --- |
| Manages different python versions? | Yes (downloads and manages python versions) |
| Default env location | Central location (e.g. `~/.conda/envs/`) |
| Customise location? | Yes |
| Default package source | conda channels or PyPI |
| Config file | `environment.yaml` or `environment.yml` |
| Speed | Slow (conda) or fast (mamba) |
| Build and publish packages? | No |
:::

<br>

| **poetry** (2019)
| <https://github.com/python-poetry/poetry>
`poetry` was focused on simplifying dependency management and packaging. It uses a `pyproject.toml` file to manage dependencies and create environments, and to build packages. It can use a specific Python version if installed on your system, but does not install Python itself.

::: {.table-greycol}
| Feature | poetry |
| -- | --- |
| Manages different python versions? | No (relies on system-installed Python, but can select among installed versions) |
| Default env location | Central cache (e.g. `~/.cache/pypoetry/virtualenvs/`) |
| Customise location? | Yes |
| Default package source | PyPI |
| Config file | `pyproject.toml` and `poetry.lock` |
| Speed | Fast |
| Build and publish packages? | Yes |
:::

<br>

| **uv** (2024)
| <https://github.com/astral-sh/uv>
`uv` is a modern tool developed by the creators of Ruff and written in Rust. It is designed to be very fast - 10-100x faster than pip or conda. It combines features of pip, venv and poetry, and can be used to build and publish packages.

::: {.table-greycol}
| Feature | uv |
| -- | --- |
| Manages different python versions? | Yes (downloads and manages python versions) |
| Default env location | Project directory (e.g. `./.venv`) |
| Customise location? | No |
| Default package source | PyPI |
| Config file | `pyproject.toml` and `uv.lock` |
| Speed | Very fast |
| Build and publish packages? | Yes |
:::
::::

::::{.r-content}
In R, the most popular tool for managing dependencies in R is `renv`. This replaced and improved upon the previous tool, `Packrat`.

However, `renv` does not manage the R version used, so we also mention `rig` (manages R version but not packages) and `rv` (a new tool that manages both).

<br>

| **renv** (2019)
| <https://github.com/rstudio/renv>
`renv` is currently the standard way for managing R package environments. It is distributed as an R package.

::: {.table-greycol}
| Feature | renv |
| -- | --- |
| Package manager? | Yes |
| Manages different R versions? | No (uses the R version it was invoked with) |
| Default env location | Project directory (e.g. `./renv`) |
| Customise location? | Yes |
| Config file | `renv.lock` |
:::

<br>

| **rig** (2021)
| <https://github.com/r-lib/rig>
`rig` is a tool for managing multiple R versions on a system - but it is not a package environment manager.

::: {.table-greycol}
| Feature | rig |
| -- | --- |
| Package manager? | No |
| Manages different R versions? | Yes (installs and switches between R versions) |
| Default env location | Central location |
| Customise location? | Yes |
| Config file | N/A |
:::

<br>

| **rv** (TBC - in development)
| <https://github.com/A2-ai/rv>
`rv` is a package manager currently in development which aims to control both the R version and all dependencies in an `rproject.toml file`. It requires all dependencies to be specified before installation, rather than taking snapshots as you go along like with `renv`. As of May 2025, it's still at a very early stage of development!

::: {.table-greycol}
| Feature | rig |
| -- | --- |
| Package manager? | Yes |
| Manages different R versions? | Yes |
| Default env location | Project directory (e.g. `./rv`) |
| Customise location? | Yes |
| Config file | `rproject.toml` plus a generated lockfile |
:::

::::

<br>

## Step-by-step instructions

:::{.python-content}
In this book and in our examples we have used **conda** - a popular, established tools that allows you to specify the Python version. This section walks you through setting up a conda environment - with the steps for other package managers overviewed in @sec-other.

::: {.callout-note}

## Mamba

**Mamba** is a drop-in replacement for conda that is often preferred as it is:

* Faster than conda.
* Better at dealing with dependency conflicts, providing more helpful messages in cases where environments fail to builds due to clashing requirements of different packages.

To use mamba, simply replace `conda` in all the commands below with `mamba`.

:::
:::

:::{.r-content}
In our repositories for this book, we have used **renv**.
:::

<br>

### Installing the environment manager

:::{.python-content}
Refer to the conda or mamba documentation for the latest instructions on installing conda/mamba for your operating system (windows, mac or linux).

* [Conda installation instructions](https://docs.conda.io/projects/conda/en/latest/user-guide/install/index.html).
* [Mamba installation instructions](https://mamba.readthedocs.io/en/latest/installation/mamba-installation.html).
:::

:::{.r-content}
Before getting started, you'll need to install `renv`.

```{.r}
install.packages("renv")
```
:::

<br>

### Creating the environment

:::{.python-content}
**Create an environment file.** In the project root, we create `environment.yaml`.

```{.bash}
touch environment.yaml
```

Within this file, we add three sections:

* **Name**. The environment name.
* **Channels**. Where to find packages (e.g. `conda-forge`).
* **Dependencies**. The packages you need.

When first creating our environment, we just list the dependencies we know we need at this point - we can always add more later! At the start of a project, you might only know one: python.

As an example, we will add `simpy` and python.

```{.bash}
name: des-example
channels:
  - conda-forge
dependencies:
  - python
  - simpy
```

::: {.callout-note}

## Conda channels

**Channels** are locations where conda stores and retrieves packages. You can choose which channel to use, and can a select a few with an order of priority.

We have used `conda-forge` which is a community-maintained channel run by volunteers. It offers a wide range of packages and is a popular choice for many users.

Other main channels include:

* `default` and `anaconda` - Maintained by Anaconda's engineers and designed for high security and stability. Organisations with 200 or more employees have to pay to use this channel (excluding students and non-commercial research at universities)
* `bioconda` - Volunteer-run, offers bioinformatics-related packages.

:::

<br>

**Build and activate the environment**. In the command line, run the following to create your environment:

```{.bash}
conda env create --file environment.yaml
```

You can then activate it (replacing `des-example` with your environment name):

```{.bash}
conda activate des-example
```

To confirm your environment contains the expected packages, run:

```{.bash}
conda list
```

This will output a list of packages, versions, builds and channels. For example, it may look similar to:

```
(des-example) amy@xps:~/Documents/hospital-des$ conda list
# packages in environment at /home/amy/mambaforge/envs/des-example:
#
# Name                    Version                   Build  Channel
_libgcc_mutex             0.1                 conda_forge    conda-forge
_openmp_mutex             4.5                       2_gnu    conda-forge
bzip2                     1.0.8                h4bc722e_7    conda-forge
ca-certificates           2025.1.31            hbd8a1cb_1    conda-forge
ld_impl_linux-64          2.43                 h712a8e2_4    conda-forge
libexpat                  2.7.0                h5888daf_0    conda-forge
libffi                    3.4.6                h2dba641_1    conda-forge
libgcc                    14.2.0               h767d61c_2    conda-forge
libgcc-ng                 14.2.0               h69a702a_2    conda-forge
libgomp                   14.2.0               h767d61c_2    conda-forge
liblzma                   5.8.1                hb9d3cd8_0    conda-forge
libmpdec                  4.0.0                h4bc722e_0    conda-forge
libsqlite                 3.49.1               hee588c1_2    conda-forge
libuuid                   2.38.1               h0b41bf4_0    conda-forge
libzlib                   1.3.1                hb9d3cd8_2    conda-forge
ncurses                   6.5                  h2d0b736_3    conda-forge
openssl                   3.5.0                h7b32b05_0    conda-forge
pip                       25.0.1             pyh145f28c_0    conda-forge
python                    3.13.3          hf636f53_101_cp313    conda-forge
python_abi                3.13                    7_cp313    conda-forge
readline                  8.2                  h8c095d6_2    conda-forge
simpy                     4.1.1              pyhd8ed1ab_1    conda-forge
tk                        8.6.13          noxft_h4845f30_101    conda-forge
tzdata                    2025b                h78e105d_0    conda-forge
```
:::

:::{.r-content}
**Create an R project**. It's best to use `renv` within an R project. In RStudio, select **File > New Project...**, and choose **Existing Directory**.

![](environment_resources/rproject1.png){fig-align="center"}

Navigate to your project directory, then select **Create Project**.

![](environment_resources/rproject2.png){fig-align="center"}

This creates:

* `.Rproj`: project file (contains some settings for the project).
* `.Rproj.user`: hidden folder with temporary project files (e.g. auto-saved source documents).

**Note:** R projects are commonly created and managed by RStudio. If you are not using RStudio, they can be difficult to set-up, as they have to be created manually. However, it is possible to use `renv` *without* an R project, as discussed in [this GitHub issue](https://github.com/rstudio/renv/issues/460). This can be done by using `setwd()` to set your repository as the current working directory, and then continuing with the steps below, running `renv::init()`.

<br>

**Initialise renv**. In your R console:

```{.r}
renv::init()
```

This creates:

* `renv/`: stores packages for the project.
* `renv.lock`: records packages and the exact versions used.
* `.Rprofile`: ensures `renv` activates when the project opens.

<br>

With `renv` initialised, you will now have an empty project library, just containing `renv`, as you can see from viewing `renv.lock` (example below). This is isolated from your previous projects, and from here, you can install the packages relevant for your current project.

Example `renv.lock`:

```
{
  "R": {
    "Version": "4.4.1",
    "Repositories": [
      {
        "Name": "CRAN",
        "URL": "https://packagemanager.posit.co/cran/latest"
      }
    ]
  },
  "Packages": {
    "renv": {
      "Package": "renv",
      "Version": "1.0.7",
      "Source": "Repository",
      "Repository": "CRAN",
      "Requirements": [
        "utils"
      ],
      "Hash": "397b7b2a265bc5a7a06852524dabae20"
    }
  }
}

```
:::

<br>

### Adding packages to the environment

:::{.python-content}

Add packages to the environment by modifying the `environment.yaml` file and then running:

```{.bash}
conda env update --file environment.yaml --prune
```

You should **specify the exact package versions** in you `environment.yaml`. If you're starting from scratch, you may not know which versions you need, so you can leave them out initially, as we did in step 1.

However, now that we have built our environment (which used the latest versions as none were specified), it is important to then record your versions in the `environment.yaml`. These are the versions you saw when running `conda list`. For example:

```{.bash}
name: des-example
channels:
  - conda-forge
dependencies:
  - python=3.13.3
  - simpy=4.1.1
```
:::

::::{.r-content}
It is possible to simply install packages using `renv::install("packagename")` or `install.packages("packagename")`.

However, we recommend using a `DESCRIPTION` file. This is because it allows you to keep a record of the main packages you installed. You'll generate a clear, readable summary of the main dependencies for your project.

**Why use a `DESCRIPTION` file?**

* **Clear requirements.** The `DESCRIPTION` file provides a clear summary of your project's main pages. This is much easier to read than `renv.lock`, which lists all the packages *and* their dependencies, making it cumbersome if you just want to see the key packages.
* **Consistency with package development**. If your project is (or might become) an R package, the `DESCRIPTION` file is the standard way to declare dependencies.
* **Alternative for environment recreation**. While `renv.lock` is the primary tool for restoring the exact environment, having a `DESCRIPTION` file is a valuable backup. If you encounter issues with `renv.lock`, you (or collaborators) can use `DESCRIPTION` to reinstall the main dependencies - with more information on this below in the section on recreating environments.
* **Explicit snapshots**. If you want precise control over what is included in `renv.lock`, a `DESCRIPTION` file enables you to use "explicit" snapshots. These mean only the packages listed in `DESCRIPTION` (and their dependencies) are recorded - as is covered below in the step on updating your `renv.lock` file.

![](environment_resources/description_vs_lock.png)

<br>

**Create a DESCRIPTION file**. Run in the terminal:

```
touch DESCRIPTION
```

Open the file and copy in the template below. You can customise some of the meta-data (e.g. package, title, authors, description).

This is a standard template. You can create an identical file with `usethis` by running `usethis::use_description()`. However, we can just create it from scratch, which helps to minimise our dependencies.

```{.bash}
Package: packagename
Title: What the Package Does (One Line, Title Case)
Version: 0.0.0.9000
Authors@R: 
    person("First", "Last", , "first.last@example.com", role = c("aut", "cre"))
Description: What the package does (one paragraph).
License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a
    license
Encoding: UTF-8
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.0.0
```

<br>

**List dependencies**. In `DESCRIPTION`, dependencies are listed under two headings:

* `Imports`: for required packages.
* `Suggests`: for optional/development packages.

For most projects (especially non-packages), it's fine to just list all your dependencies under `Imports` for simplicity, as - assuming you're using the implicit renv snapshot type (described below) - `renv` will only detect and install packages listed under `Imports` and used in your scripts (and not necessarily those under `Suggests`).

The distinction between `Imports` and `Suggests` is more relevant when [constructing your research as an R package](package.qmd), as it will distinguish between those necessary for the core simulation and those for other analysis and tests.

At the very beginning of your project, your `DESCRIPTION` file might only include a few packages. For example, if you are starting with just the `simmer` package, your Imports section would look like this:

```{.r}
Imports:
    simmer
```

As your project develops and you find yourself using additional packages, simply **add each new dependency to the `Imports` section** of your `DESCRIPTION` file.

If you are following along with this book, you can use the following `DESCRIPTION` snippet to include all the packages needed to run the provided code in this book:

```{.r}
Imports:
    simmer,
    magrittr,
    dplyr,
    purrr,
    rlang,
    tidyr,
    tidyselect,
    future,
    future.apply,
    ggplot2,
    tibble,
    gridExtra,
    R6
Suggests:
    testthat (>= 3.0.0),
    patrick,
    lintr,
    devtools,
    xtable,
    data.table,
    mockery
Config/testthat/edition: 3
```

**Note:** In the [R Packages](https://r-pkgs.org/description.html) book, they recommend that versions are not specified in `DESCRIPTION`. Instead, they suggest that no version is specified - or that a minimum version is specified, if you know that an older version of specific package/s would break the code. This is why it is important to also create an `renv.lock` file (as below), so you do have a record of the exact versions used.

<br>

**Install packages from `DESCRIPTION`**. Run the following command in your console. This will install the packages from `DESCRIPTION`, and will determine and install the dependencies of those packages too.

```{.r}
renv::install()
```

<br>

**Update `renv.lock`**. To take a snapshot of your environment and update your `renv.lock` file, run:

```{.r}
renv::snapshot()
```

This will update the lock file with a full list of the exact packages and dependencies, including the **versions** you have installed, providing a clear record of your working environment.

There are three snapshot types:

* **Implicit** - records any packages (and their dependencies) listed in `DESCRIPTION` or used in your code.
* **Explicit** - only records packages (and their dependencies) listed in `DESCRIPTION`.
* **All** - records all packages in your environment.

The default snapshot type is **implicit**, and we recommend this approach. This is because it will catch any packages you are using but that you have forgot to add to `DESCRIPTION` (although it is best to remember to record these in `DESCRIPTION`, so you have a nice clear list of packages, and don't have to delve into `renv.lock` if you're having issues).

The downside to this snapshot type if that it may include unnecessary packages if you include old scripts in your repository that use packages you no longer need. However, this can be avoided by removing old scripts (good practice!).

If you want to check your snapshot type, run this command in the R console:

```{.r}
renv::settings$snapshot.type()
```

You can then change it if desired using one of:

```{.r}
renv::settings$snapshot.type("implicit")
renv::settings$snapshot.type("explicit")
renv::settings$snapshot.type("all")
```

<br>

:::{.callout-tip}
## System dependencies

Some R packages require external system libraries. The exact requirements will depend on which packages you use, what operating system you have, and whether you have used R before.

If these system libraries are missing, package installation may fail, even if you have the correct R package versions.

For example, working on Ubuntu, we found that we had to install the following system dependencies for `igraph`:

```{.bash}
sudo apt install build-essential gfortran
sudo apt install libglpk-dev libxml2-dev
```

You should list any system dependencies that you are aware of in your project's README or setup instructions.
:::

::::

<br>

### Recreating an existing environment

:::{.python-content}
When working on a project from scratch, you will often build up your environment organically and iteratively as you find more packages you want to use. However, to follow along with this book and ensure everything works as expected, you can use the full environment provided below. Copy this into your `environment.yaml` (feel free to alter the name!):

```{.bash}
name: des-example
channels:
  - conda-forge
dependencies:
  - ipykernel=6.29.5
  - jinja2=3.1.5
  - joblib=1.4.2
  - nbconvert=7.16.6
  - nbformat=5.10.4
  - nbqa=1.9.0
  - numpy=2.2.2
  - pandas=2.2.3
  - pip=25.0
  - plotly_express=0.4.1
  - pylint=3.3.4
  - pytest=8.3.4
  - pytest-xdist=3.6.1
  - python=3.13.1
  - rich=13.9.4
  - simpy=4.1.1
  - pip:
    - kaleido==0.2.1
    - sim-tools==0.8.0
```

Then update your environment to include these packages (after running `conda activate des-example`) with:

```{.bash}
conda env update --file environment.yaml --prune
```
:::

:::{.r-content}
When you want to recreate an environmentâ€”such as for an old project or when collaboratingâ€”you have two main options, depending on which files are available:

| Method | What does it install? | Best for... |
| - | - | - |
| **From `renv.lock`** | Installs the exact package versions (and their dependencies) used previously | Full reproducibility; restoring the original environment exactly
| **From `DESCRIPTION`** | Installs the main packages listed (and their dependencies), but uses the latest available versions (unless specified) | Getting started quickly or if `renv.lock` is missing or problematic |

<br>

**Restoring from `renv.lock` (preferred)**. If the project includes an `renv.lock` file, use this as your first option. This file records the exact versions of all packages used, enabling you to recreate the environment as it was originally (*except for R version and operating system differences).

To restore the environment, run in your R console:

```{.r}
renv::restore()
```

This will attempt to install all packages at the precise versions specified.

Occasionally, you may encounter issues - such as conflicts, unavailable packages, or operating system differences - especially with older projects or across different systems.

<br>

**Rebuilding from `DESCRIPTION`**. If `renv.lock` is unavailable or causes problems, you can use the `DESCRIPTION` file.  This file lists the main package dependencies, but typically does not specify exact versions (unless you have set minimum versions for specific needs).

To install packages listed in `DESCRIPTION`, run:

```{.r}
renv::install()
```

This will install the latest available versions of the listed packages and their dependencies. This approach is less precise than using `renv.lock`, so results may differ slightly from the original environment, especially if package updates have introduced changes.

In theory, the R ecosystem aspires to maintain backwards compatability, meaning that code written for older package versions should continue to work with newer ones. However, in practice, there is no strict guarantee of backward compatibility in R, either for the core language or for contributed packages.

As discussed in the [R packages](https://r-pkgs.org/lifecycle.html) book:

> "If we're being honest, most R users donâ€™t manage package versions in a very intentional way. Given the way `update.packages()` and `install.packages()` work, itâ€™s quite easy to upgrade a package to a new major version without really meaning to, especially for dependencies of the target package. This, in turn, can lead to unexpected exposure to breaking changes in code that previously worked. This unpleasantness has implications both for users and for maintainers."

Hence, using a lockfile like `renv.lock` is the only reliable way to ensure that your environment is recreated exactly as it was - but `DESCRIPTION` can serve as a valuable back-up when this doesn't work, and otherwise just as a handy summary of the main packages.

<br>

**If neither file is provided**. If you have neither a `renv.lock` nor a `DESCRIPTION` file, you can try to create a `DESCRIPTION` file based on your knowledge of the project and its required packages.

**Summary:**

We can use `renv` to create a reproducible environment in R. In the process above, we generated two key files:

* `DESCRIPTION` - lists project's primary packages with any minimum version requirements, but not exact versions.
* `renv.lock` - complements this by recording the precise versions of all packages and their dependencies.

These work together to both provide (a) a comprehensive record of your project environment, and (b) enable yourself or others to reconstruct the environment.

:::

<br>

## Other examples {#sec-other}

If you're interested in using one of the other tools for dependency management, we've provided some brief information on each below, and direct you to other sources for a more detailed explanation of how to use them.

::::{.python-content}

::: {.callout-note collapse="true"}
## venv

venv
:::

::: {.callout-note collapse="true"}
## poetry

poetry
:::

::: {.callout-note collapse="true"}
## uv

uv
:::

::::

::::{.r-content}


::: {.callout-note collapse="true"}
## rig

rig
:::

::::

<br>

## Further information

:::{.python-content}
* ["An unbiased evaluation of environment management and packaging tools"](https://alpopkes.com/posts/python/packaging_tools/) from Anna-Lena Popkes 2024.
* ["Python dependency management is a dumpster fire"](https://nielscautaerts.xyz/python-dependency-management-is-a-dumpster-fire.html) from Niels Cautaerts 2024.
* ["Is conda free"](https://www.anaconda.com/blog/is-conda-free) from Dave Clements 2023.
:::

:::{.r-content}
* ["9. DESCRIPTION" from R Packages](https://r-pkgs.org/description.html) by Hadley Wickham and Jennifer Bryan.
* ["21. Lifecycle" from R Packages](https://r-pkgs.org/lifecycle.html) by Hadley Wickham and Jennifer Bryan.
:::
