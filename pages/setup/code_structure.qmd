# Code organisation {#sec-code_structure}

:::{.guidelines}
* Heather et al. 2025: Minimise code duplication.
* NHS Levels of RAP (ðŸ¥ˆ): Reusable functions and/or classes are used where appropriate.
:::

It might seem convenient to write all your code in a single script and simply copy-and-paste sections when you need to reuse something. However, this approach quickly becomes unmanageable as your project grows. Organising your code with functions, classes, and separate files has several benefits:

* **Easier to read and collaborate on**. Code with a standardised, logical structure-where complex processes are broken into manageable parts-is much easier to understand. This makes your code more accessible for you and others to contribute to, both now and in the future.
* **Simpler to maintain with fewer errors**. When different components are isolated into separate chunks, they are easier to update, test, and debug. This reduces mistakes and makes it easier to add new features.
* **No duplication**. Writing reusable code (like functions and classes) means changes only need to be made in one place. In contrast, duplicated code requires updates everywhere it appears, increasing the risk of missing something.

<br>

## Programming paradigms

As you think about organising your code, itâ€™s helpful to consider the different approaches, or "**programming paradigms**", that shape how code is structured. In Python and R, the most common paradigms are:

* Procedural programming.
* Functional programming.
* Object-oriented programming (OOP).

<!--TODO: add diagram-->

<br>

### Procedural programming

In procedural programming, code is organised into **functions** that are run **step-by-step**, in a specific sequence. Each function represents a clear step in the process, and the program flows from one step to the next.

As the code runs, data is passed between functions. Data structures (like lists) are **mutable**. This means they can be changed as the program runs. For example, you can add, remove or update items directly, rather than creating a new version each time something changes.

Procedural programs also commonly use **loops** (such as `for` or `while`) to repeat actions as needed.

<br>

### Functional programming

In functional programming, code is still organised into functions, but these are always **pure functions**. A pure function always returns the same output for the same input and does not affect anything outside itself. This means it doesnâ€™t change variables, files, or data elsewhere in the program-its only effect is to return a value.

In this paradigm, functions are treated as "first-class citizens". This means that they can be assigned to variables, passed as arguments to other functions, and returned from functions. Whilst you can do this in procedural programming, it is a core feature of functional programming, which is used to build programs in a different way. It relies on them much more.

Data structures in functional programming are **immutable** - i.e. once created, they cannot be changed. Instead of updating or modifying existing data, new data structures are created for every change.

Instead of traditional loops (`for`, `while`), functional programming uses recursion or higher-order functions to repeat actions. This avoids mutable state and aligns with the paradigm's empahsis on predicability and safety. 


::: {.python-content}

#### Example in python

In this example, we have a function which manually loops, checks and updates the list step-by-step.

```{python}
def procedural_sum(n):
    """
    Calculate the sum of numbers from 1 to n using a procedural approach.

    This function demonstrates procedural programming by using a loop
    and a mutable variable to accumulate the sum.

    Parameters
    ----------
    n: int
        The upper limit of the range to sum.

    Return
    ------
    int
        The sum of numbers from 1 to n, inclusive.
    """
    total = 0
    for i in range(1, n+1):
        total += i
    return total


print(procedural_sum(5))
```

:::

::: {.r-content}

#### Example in R

```{.r}
```

:::

### Functional programming

::: {.python-content}

#### Example in python

In this function, we describe the desired transformations, and the details of the sequence are handled for us.

```{python}
def functional_sum(n):
    """
    Calculate the sum of numbers from 1 to n using a functional approach.

    This function demonstrates functional programming by using the built-in
    'map' and 'sum' functions without explicit loops or mutable state.

    Parameters
    ----------
    n: int
        The upper limit of the range to sum.

    Return
    ------
    int
        The sum of numbers from 1 to n, inclusive.
    """
    return sum(map(lambda x: x, range(1, n+1)))


print(functional_sum(5))
```

:::

::: {.r-content}

#### Example in R

```{.r}
```

:::

### Object oriented programming
- classes with attributes and methods


::: {.python-content}

#### Example in python

```{python}
class SumCalculator:
    """
    A class to calculate the sum of numbers from 1 to n using an
    object-oriented approach.

    This class demonstrates object-oriented programming by encapsulating
    data (n) and behavior (sum calculation) within an object.

    Attributes
    ----------
    n: int
        The upper limit of the range to sum.
    """

    def __init__(self, n):
        """
        Initialise the SumCalculator with the upper limit n.

        Parameters
        ----------
        n: int
            The upper limit of the range to sum.
        """
        self.n = n

    def calculate_sum(self):
        """
        Calculate the sum of numbers from 1 to self.n.

        Return
        ------
        int
            The sum of numbers from 1 to n, inclusive.
        """
        total = 0
        for i in range(1, self.n + 1):
            total += i
        return total


calculator = SumCalculator(5)
print(calculator.calculate_sum())
```

:::

::: {.r-content}

#### Example in R

```{.r}
```

:::

## Which to use?

procedural and object oriented most common
though functional is used
often in python will blend paradigms

e.g. list comprehension is quite functional... "emphasis on purity and immutability-list comprehensions do not produce side effects or leak variables into the outer scope"
whilst for loop is classic of proecudral... execute code repeatedly... often side effects of modifying variables appending listsi

## Further reading

* ["Introduction to Programming Paradigms"](https://www.datacamp.com/blog/introduction-to-programming-paradigms) by Samuel Shaibu (Datacamp, 2024).