# Code organisation {#sec-code_structure}

{{< include ../../scripts/language-selector.html >}}

:::{.guidelines}
* Heather et al. 2025: Minimise code duplication.
* NHS Levels of RAP (ü•à): Reusable functions and/or classes are used where appropriate.
:::

It might seem convenient to write all your code in a single script and simply copy-and-paste sections when you need to reuse something. However, this approach quickly becomes unmanageable as your project grows. The main tools you can use to **organise** your code are **functions** and **classes**. Using these has has several benefits:

* **Easier to read and collaborate on**. Code is clearer and easier to understand for you and others.
* **Simpler to maintain with fewer errors**. Complex processes are broken into manageable parts. This makes them easier to update, test, and debug.
* **No duplication**. Writing reusable code (like functions and classes) means changes only need to be made in one place, such as when you are updating or fixing a bug. In contrast, duplicated code requires updates everywhere it appears, and you may miss some.

<br>

## Functions

Functions group code into reusable blocks that perform a specific task.

Example:

::: {.python-content}

```{.python}
def add(a, b):
    return a + b
```
:::

::: {.r-content}

```{.r}
add <- function(a, b) {
  a + b
}
```
:::

<br>

## Classes

Classes bundle data ("**attributes**") and behaviour ("**methods**"). You create an **instance** of a class (an "object") to use it.

::: {.python-content}

Example:

```{.python}
class Dog:
    def __init__(self, name):
        self.name = name
    def bark(self):
        print(f"{self.name} says woof!")

fido = Dog("Fido")
fido.bark()  # Output: Fido says woof!
```
:::

::: {.r-content}
Classes are less common in R, but are used sometimes for complex or structure tasks. R supports several class systems, including S3, S4 and R6. The R6 class is shown as an example below, and is the most similar to classes in Python.

Example:

```{.r}
library(R6)

Dog <- R6Class("Dog",
  public = list(
    name = NULL,
    initialize = function(name) {
      self$name <- name
    },
    bark = function() {
      cat(self$name, "says woof!\n")
    }
  )
)

# Create an instance and use it:
fido <- Dog$new("Fido")
fido$bark()  # Output: Fido says woof!
```
:::

<br>

### Subclasses and inheritance

A **subclass** (or "child class") is a class that inherits from another class (the "parent" or "superclass"). Subclasses can **reuse or extend** the behaviour of their parent.

Example:

::: {.python-content}

```{.python}
class Animal:
    def __init__(self, name, diet):
        self.name = name
        self.diet = diet
    
    def describe(self):
        return f"{self.name} is a {self.diet}"


class Cheetah(Animal):
    def __init__(self, name):
        super().__init__(name, diet="carnivore")
    
    def activity(self):
        base = self.describe()
        return f"{base}. Sprinting at 70 mph!"


charlie = Cheetah("Charlie")
print(charlie.activity())
# Output: Charlie is a carnivore. Sprinting at 70 mph!
```

:::

::: {.r-content}

```{.r}
library(R6)


Animal <- R6Class("Animal",
  public = list(
    name = NULL,
    diet = NULL,
    initialize = function(name, diet) {
      self$name <- name
      self$diet <- diet
    },
    describe = function() {
      paste(self$name, "is a", self$diet)
    },
  )
)


Cheetah <- R6Class("Cheetah",
  inherit = Animal,
  public = list(
    initialize = function(name) {
      super$initialize(name, diet = "carnivore")
    },
    activity = function() {
      base <- super$describe()
      paste(base, "Sprinting at 70 mph!")
    }
  )
)


charlie <- Cheetah$new("Charlie")
cat(charlie$activity())
# Output: Charlie is a carnivore Sprinting at 70 mph!
```

:::

<br>

## Programming paradigms

**Programming paradigms**" define different ways to organise code. The table below provides a overview of the most common paradigms you'll use:

| Paradigm | Main object used | Key characteristics |
| - | - | --- |
| **Procedural programming** | Functions | ‚Ä¢  Code runs **step-by-step** using functions, often passing data from one to the next<br>‚Ä¢ Data structures (like lists) are usually **mutable** (i.e. can be changed directly).<br>‚Ä¢ Use **loops** (`for`, `while`) to repeat actions. |
| **Functional programming** | Functions | ‚Ä¢ Uses **pure functions** (always same output for same input, no side effects - i.e. doesn't change variables elsewhere, only effect is to return value)<br>‚Ä¢ Functions are "first-class citizens" (i.e. can be assigned to variables, passed as arguments, or returned from functions).‚Ä¢ Data structures are **immutable** (can't be changed; new ones are created for each change).‚Ä¢ Repeats actions with **recursion** (functions calling themselves) and **higher-order functions** (e.g. Python's `map`, R's `sapply`). |
| **Object-oriented programming (OOP)** | Classes/Objects | ‚Ä¢ Orgnaises code into **objects** (instances of classes) that bundle data (attributes) and behaviour (methods).<br>‚Ä¢ Data and methods are **bundled together** ("encapsulation").<br>‚Ä¢ Can **hide** details through private attributes and methods ("abstraction").<br>‚Ä¢ A class can **inherit** from another class.<br>‚Ä¢ The same object can behave diferently depending on context ("polymorphism"). |

In practice, both Python and R often mix paradigms, choosing what works best for the problem at hand.

This table just provides a brief introduction to the paradigms. If you're new to these concepts, don't worry. What matters most is understanding that you can use functions or classes to organise your code, and that certain features-like keeping functions ‚Äúpure‚Äù (not changing things outside the function) or using immutable data-can help make your code more robust and easier to maintain. These are just tools to help you write better code. Use the approaches that make sense for your specific project and context-you don‚Äôt have to follow any single style rigidly.

You can see the resources listed in @sec-code_structure_further_reading below for more in-depth explanation of programming paradigms, if of interest.

## When to use functions and classes

In this book, you'll see both functions and classes used, depending on what made sense for the task. Generally, we've used more classes in Python and more functions in R-as is typical, since R code often relies less on classes-but neither approach is exclusive, and often either could have been used. The choice is mostly a matter of language style, clarity, and what fits best for the problem at hand.

In general, **functions** are ideal when you want to group reusable actions or calculations, to just perform an operation or calculation.
**Classes** become useful when you need to keep track of state or have several related functions that operate on the same kind of data. Choose the approach that best matches the problem you‚Äôre solving. There's no strict rule; often, a mix of both is the most practical and maintainable solution.

## Further reading {#sec-code_structure_further_reading}

* ["Introduction to Programming Paradigms"](https://www.datacamp.com/blog/introduction-to-programming-paradigms) by Samuel Shaibu (Datacamp, 2024).
* ["OOP vs Functional vs Procedural"](https://www.scaler.com/topics/java/oop-vs-functional-vs-procedural/) (Scaler Topics, 2022).