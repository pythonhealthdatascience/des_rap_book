# Structuring our model as a package {#sec-package}

{{< include ../../scripts/language-selector.html >}}

> @sec-guidelines:
>
> * NHS Levels of RAP (🥈): Code is well-organised following standard directory format.
> * NHS Levels of RAP (🥇): Code is fully packaged.

<br>

Building our simulation model as a package has several advantages:

* The model is **installed** in our environment and can then be easily used anywhere else in our directory (or even from other directories) without needing to specify a system path.
* It encourages us to create a well-organised repository following **standardised** established package structures.
* It helps keep the model and analysis code **separate**, improving maintainability, reusability, and reducing the risk of unintended side effects.
* It supports automated **testing** frameworks which can verify functionality (@sec-tests).

<br>

::: {.python-content}

## Create the package structure

First, let's create the basic directory structure for our simulation package.

<br>

**1. Create folder.** Create a folder called 📁`simulation/` in your project directory.

```{.bash}
mkdir simulation
```

<br>

**2. Make init file.** Inside the 📁`simulation/` folder, create an 📄`__init__.py` file.

```{.bash}
touch simulation/__init__.py
```

Open this file and copy in some basic metadata.

```{.python}
"""SimPy Discrete-Event Simulation (DES) Model.
"""

__version__ = "0.1.0"
```

<br>

**3. Add a function.** Within 📁`simulation/`, create a file called 📄`model.py`.

```{.bash}
touch simulation/model.py
```

In this, we will add our model code. For now, just copy in this simple function that generates a list of numbers. We will add some real code for our model later.

```{.python}
"""Core simulation model functionality."""


def run_simulation(duration=100):
    """
    Run a simple dummy simulation for the specified duration.

    Parameters
    ----------
    duration: int
        The length of time to run the simulation.

    Returns:
        dict:
            Dummy simulation results.
    """
    return {
        "duration": duration,
        "status": "completed",
        "results": [i for i in range(duration) if i % 10 == 0]
    }

```

<br>

**4. Make pyproject file.** Create a 📄`pyproject.toml` file in the project root directory (outside the 📁`simulation` folder).

```{.bash}
touch pyproject.toml
```

Copy the text below into this file. This provides instructions for building the package. We're using `flit` as our build tool because of its simplicity. The `dynamic` field tells flit to extract the version and description from our 📄`__init__.py` file.

```{.bash}
[build-system]
requires = ["flit"]
build-backend = "flit_core.buildapi"

[project]
name = "simulation"
dynamic = ["version", "description"]
```

<br>

Our directory is now recognisable as a package - it contains an 📄`__init__.py` file, and there is information about the package in 📄`pyproject.toml`.

Your directory should now look like this:

```{.bash}
our_directory/
├── simulation/             # Main package directory
│   ├── __init__.py         # Makes the directory a package
│   └── model.py            # Our function
├── .gitignore
├── environment.yaml
├── LICENSE
├── pyproject.toml          # Package metadata
└── README.md
```

<br>

## Update the environment

<br>

**5. Add package to environment file**. Edit the `environment.yaml` file created in @sec-environment to add the local package. We use the `-e` flag to install it in "editable" mode, which means it will update with any changes to the source code in 📁`simulation/`.

We add the following line within the `pip` installs:

```{.bash}
  - pip:
    - -e .[dev]
```

So our full environment file is now:

```{.bash}
name: des-example
channels:
  - conda-forge
dependencies:
  - ipykernel=6.29.5
  - jinja2=3.1.5
  - joblib=1.4.2
  - nbconvert=7.16.6
  - nbformat=5.10.4
  - nbqa=1.9.0
  - numpy=2.2.2
  - pandas=2.2.3
  - pip=25.0
  - plotly_express=0.4.1
  - pylint=3.3.4
  - pytest=8.3.4
  - pytest-xdist=3.6.1
  - python=3.13.1
  - rich=13.9.4
  - simpy=4.1.1
  - pip:
    - kaleido==0.2.1
    - sim-tools==0.8.0
    - -e .[dev]
```

<br>

**6. Update the environment**. To update our environment, adding our new package, execute the following in the command line (after running `conda activate des-example`):

```{.bash}
conda env update --file environment.yaml --prune
```

If you run `conda list`, you should now see our `simulation` package listed as a dependency like so:

```
# Name                    Version                   Build  Channel
simulation                0.1.0                    pypi_0    pypi
```

<br>

## Create a notebook to test your package

We will run our model and analyse results within **Jupyter notebooks**, as they allow us to combine code, results and explanations in one document. This can help make our methods and results easier to share, read through and understand.

<br>

**7. Create directory and notebook**. We create a dedicated directory for our notebooks in the project root (📁`notebooks/`), and add a notebook (📄`simulation_test.ipynb`). These can be created via your operating system's file manager, or with the command line:

```{.bash}
mkdir notebooks
touch notebooks/simulation_test.ipynb
```

<br>

**8. Check our package works.** Open `notebooks/simulation_test.ipynb` and add the following code. This will test that we are able to import our package and use the basic function we had created.

```{.python}
# Import our simulation package
from simulation.model import run_simulation

# Run the simulation with default parameters
results = run_simulation()
print(f"Simulation completed with duration: {results['duration']}")
print(f"Results: {results['results']}")

# Run with a different duration
long_results = run_simulation(duration=200)
print(f"Longer simulation completed with duration: {long_results['duration']}")
print(f"Number of results: {len(long_results['results'])}")
```

When you run the notebook cells, you should see an output confirming that the simulation function runs and returns results, if everything is set up correctly.

```
Simulation completed with duration: 100
Results: [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
Longer simulation completed with duration: 200
Number of results: 20
```

<br>

### Further information

* ["How I use Python to organize my data analyses"](https://joshuacook.netlify.app/posts/2024-07-27_python-data-analysis-org/) from Joshua Cook 2024 

:::

::: {.r-content}

### Creating a package

A basic R package structure looks like this:

```{.bash}
our_directory/
├── R/                  # Directory containing R functions
│   ├── model.R         # Code for the model
│   └── ...             # Other .R files (e.g. parameters, replications)
├── man/                # Documentation (generated from roxygen comments)
├── tests/              # Unit tests
├── DESCRIPTION         # Package metadata
├── NAMESPACE           # Package exports (usually generated)
└── rmarkdown/          # Analysis notebooks
```

The core of our package is the 📁`R/` directory, which contains all our simulation functions within R files (e.g. 📄`model.R`). Each function should be documented using roxygen2-style comments that will automatically generate the documentation in the 📁`man/` directory. Writing these docstrings is covered in @sec-docstrings.

The `DESCRIPTION` file contains essential metadata about the package:

```{.bash}
Package: simulation
Type: Package
Title: Simulation
Version: 0.1.0
Authors@R: c(
    person(
      "Amy", "Heather",
      email = "a.heather2@exeter.ac.uk",
      role = c("aut", "cre")
    )
  )
URL: https://github.com/pythonhealthdatascience/rap_template_r_des
Description: Template reproducible analytical pipeline (RAP) for simple R
    discrete-event simulation (DES) model.
License: MIT + file LICENSE
Encoding: UTF-8
LazyData: true
RoxygenNote: 7.3.2
Imports:
    simmer,
    magrittr,
    dplyr,
    purrr,
    rlang,
    tidyr,
    tidyselect,
    future,
    future.apply,
    ggplot2,
    tibble,
    gridExtra,
    R6
Suggests:
    testthat (>= 3.0.0),
    patrick,
    lintr,
    devtools,
    xtable,
    data.table,
    mockery
Config/testthat/edition: 3
```

### Installing and using the package

We use the `devtools` package to build and install our package:

```{.r}
# Install the package from the local directory
devtools::install()

# Load the package
library(simulation)

# Now you can use functions from the package...
```

When developing the package, these commands are particularly helpful:

* `devtools::document()` to reproduce documentation in 📁`man/` after changes to the docstrings.
* `devtools::check()` to build and check the package follows best practices.
* `devtools::install()` to load the latest version of the package into your environment.
* `devtools::test()` to run the tests in 📁`tests/`.

For analysis and reporting, we store our files in the 📁`rmarkdown/` directory rather than in 📁`vignettes/`. This is because files in 📁`vignettes/` are re-run with every package build/check. For simulations with longer run times, this can be inefficient - although this may be of interest for quicker simulations, as it will help ensure you always run everything from scratch. However, file paths for saving outputs can cause errors during the package build process.

<!--TODO: add a better context on what vignettes are, and how people talking about using r for research often mention putting your stuff in there -->

### Further information

* ["Open, Reproducible, and Distributable Research With R Packages"](https://dante-sttr.gitlab.io/r-open-science/) from the DANTE Project - for example, this page on [vignettes](https://dante-sttr.gitlab.io/r-open-science/reports-manuscripts.html).
* ["Sharing and organizing research products as R packages"](https://doi.org/10.3758/s13428-020-01436-x) from Vuorre and Crump 2020

:::

